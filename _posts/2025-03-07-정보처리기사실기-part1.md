---
title: 정보처리기사 실기 PART1. 소프트웨어 구축
description: 소프트웨어 구축 이론 정리
author: GH Lee
date: 2025-03-07 00:00:00 +0900
categories: [License]
tags: [License, Note]
pin: false
math: false
mermaid: false
---
## Ch1. 소프트웨어 공학 개념

### 소프트웨어 공학
품질 높은 소프트웨어를 효율적으로 개발하기 위한 방법, 도구, 이론

#### 3R : 역공학, 재공학, 재사용

##### 역공학(Reverse Engineering)
이미 개발된 시스템의 소스코드에 기반하여 문서(설계명세서, 요구분석서)를 역산출하는 방식

##### 재공학(Re-Engineering)
- 기존 소프트웨어를 개선, 유지보수하여 생산성 위기를 해결하는 방식
- 과정: 분석 - 재구성 - 역공학 - 이관
  - 분석: 기존 소프트웨어를 검토하여 재공학 대상을 선정
  - 재구성: 소프트웨어 구조개선 목적으로 코드를 재구성하되, 외적 기능은 변경하지 않음
  - 역공학: 소프트웨어 소스코드를 분석해서 설계 수준 도출
  - 이관: 다른 운영체제, 프레임워크에서 사용할 수 있도록 소프트웨어 변환 작업

##### 재사용(Reuse)
- 기존 소프트웨어의 전체 또는 일부를 다시 사용하는 방식
- 범위
  - 함수, 객체 재사용: 클래스나 함수 단위로 재사용
  - 컴포넌트 재사용: 독립적인 소프트웨어 컴포넌트를 재사용
  - 애플리케이션 재사용: 애플리케이션 전체 또는 일부를 재사용
- 재사용 방법
  - 합성중심(Composition Based, 블록구성): 블록처럼 소프트웨어 부품을 조합해서 전체를 완성
  - 생성중심(Generation Based, 패턴구성): 추상화된 형태의 명세를 구체화하여 특정 패턴을 적용하는 방식으로 프로그램 생성

#### 개발단계
계획 - 요구사항분석 - 설계 - 구현 - 테스트 - 유지보수
- 계획: 개발 내용을 정의하고 비용/기간을 예측해서 프로젝트를 발주하거나 폐기함
- 요구사항분석: 고객의 머리속에 있는 생각을 끄집어내서 구체화
- 구현: 개발 진행(코딩, 디버깅, 단위테스트)
- 테스트: 요구사항대로 구현됐는지 확인
- 유지보수: 프로그램 운영 및 기능 개선

### 소프트웨어 개발 방법론

#### 구조적 방법론
**정의**
- <span style="color: red;">절차지향</span>적인 개발 방법론
- <span style="color: red;">하향식</span>: 사전에 정의된 구조로 코드를 작성하고 순차적으로 실행 (ex. C, Fortran, Cobol)

<span style="color: red;">**구성요소**</span>
- 데이터흐름도 (DFD, Data Flow Diagram): 전체적인 데이터 흐름 표현
- 데이터사전 (DD, Data Dictionary): 시스템에서 사용되는 데이터 세부사항을 문서화
- 상태전이도 (STD, State Transition Diagram): 시스템이 동작에 의한 상태의 변화를 모델링
- 소단위명세서(Minispec): 모듈의 기능과 로직을 상세히 설명
- ERD(Entity Relationship Diagram): DB 구조를 설명

#### 정보공학 방법론
**정의**
- 기업 내부 데이터 중심 접근 방식으로 sw개발을 넘어 기업경영전략에 초점
- 계획, 분석, 설계, 구축에 정형화된 기법을 적용

#### 객체지향 방법론
**정의**
- 모든 유무형을 객체화하는 개발 방법론
- 상향식: 객체와 클래스간의 관계를 식별하고 이를 설계 모델로 변환 (ex. JAVA, Javascript, Python)

##### <span style="color: red;">구성요소: 객체(인스턴스), 클래스, 속성, 메서드, 메시지</span>
- 클래스: 틀
- 속성
- 메서드: 연산
- 객체(인스턴스): 클래스를 통해 실체화된 것
- 메시지: 객체간 소통 수단

![객체지향 방법론 구성요소](/assets/img/2025-03-07-정보처리기사실기-part1/oop-component.png)

##### 특징
- 정보은닉: 내부구조를 외부로부터 숨겨서 안정성 높임
- 캡슐화: 의사소통을 위해 특정 인터페이스를 제공해서 외부로부터 직접 접근을 막음
- 상속: 재사용과 확장성을 위해 기존 클래스의 속성을 받아서 새로운 클래스를 작성하는 기법 (부모 클래스로부터 자식 클래스가 속성을 물려받는 것)
- 추상화: 공통된 성질을 모아서 생산, 유지보수 효율성 증가
- 다형성: 하나의 인터페이스로 다양한 형태의 구현을 가지는 방식
  - 오버로딩: 동일한 메서드에 입력하는 인자 개수, 타입에 따라 서로 다른 결과값을 가지는 방식
  - 오버라이딩: 상속 받은 메서드를 재정의하는 방식

#### CBD(Component Based Development) 방법론
**정의**
- 재사용가능한 컴포넌트를 개발하거나 상용 컴포넌트를 조합해서 어플리케이션 개발
- 확장성이 좋아 새로운 기능 추가에 용이

#### 애자일(Agile) 방법론
**정의**
- 변화에 빠르고 유연하게 대응하는 개발방식
- 소프트웨어 개발의 민첩성과 효율성을 강조

**종류**
- XP(Extreme Programming): 반복적이고 점진적인 개발과 고객의 참여를 반복하여 안정성을 확보하고 개발효율성을 높임
- 스크럼(SCRUM): 유연하고 생산적인 프로젝트 관리 방식을 적용해서 효율적인 협업 지원
- FDD(Feature-Driven Development): 기능 중심 반복적 개발
- Crystal 개발 방식: 프로젝트 크기와 중요도에 따라 최적의 개발방식을 선택

### 소프트웨어 개발 모델

#### 폭포수 모델
- 선형 순차적으로 계획 → 분석 → 설계 → 구현 → 테스트 → 운영 순으로 진행하는 전통적인 개발 모형
- 안정성이 매우 높으며 이전 단계로 돌아가기 어려움

#### 프로토타이핑 모델
- 고객의 요구사항으로 <span style="color: red;">시제품</span>을 만들어 결과를 예측하는 개발 모형

#### 나선형(Spiral) 모델
- 폭포수 모델 + 프로토타이핑 모델
- "계획 수립 → <span style="color: red;">위험 분석</span> → 프로토타이핑 개발 → 고객평가 피드백" 절차를 점진적으로 진행하는 개발 모형

#### RAD(Rapid Application Development) 모델
- CASE 도구를 활용해서 짧은 개발주기내에 개발
- 상위 CASE 도구: 분석, 설계
- 하위 CASE 도구: 개발, 테스트, 문서화

#### V 모델
개발절차에 따라 테스트/검증 절차를 강조한 모델
테스트 단계: 단위테스트 → 통합테스트 → 시스템테스트 → 인수테스트

![V 모델](/assets/img/2025-03-07-정보처리기사실기-part1/v-model.png)

#### 4세대 기법(4th Generation Techniques)
요구사항 명세서 기반으로 코드를 자동 생성하는 기법

### Agile 방법론

#### 개념
짧은 주기 동안 반복 작업을 통해 신속하고 지속적으로 작동가능한 소프트웨어를 개발하는 방식
작은 구성요소를 빠르게 제공하여 변화에 민감하게 대응가능

#### 종류1: XP(Extream Programming)
개발문서보다 소스코드에 중점
고객의 요구사항에 유연하게 대응하기 위해 고객 참여와 짧은 주기 개발 과정을 반복 진행 
5가지 핵심가치: <span style="color: red;">용기, 단순성, 의사소통, 피드백, 중점</span>

#### 종류2: SCRUM
기능개발, 개선에 우선순위 부여해서 개발 집중도 높임
짧은 개발 주기마다 결과물 제공

**용어**
- 제품백로그: 제품 단위 요구기능 목록
- 스프린트: 반복적이고 짧은 개발주기 단위
- 스프린트 계획회의: 스프린트 목표 및 스프린트 백로그 목표 계획 회의
- 스프린트 백로그: 스프린트 목표를 위한 작업 목록
- 스크럼 마스터: 스크럼 프로세스 및 활용을 보장하는 프로젝트 관리자

#### 기타 종류
- Crystal
- FDD(Feature-Driven Development)
- ASD(Adaptive Software Development): 합동 애플리케이션 개발에서 혼란을 규정하고, 혼란에 적응할 수 있는 방법론
- Lean: 낭비요소를 제거하고 품질을 향상시키는 방법론

### Ch2. 프로젝트 계획 및 분석

#### 프로젝트 계획

##### 프로젝트 관리

**개념**
- 한정된 기간, 예산, 자원을 활용하여 사용자에게 만족스러운 제품/서비스를 개발하는 기술·관리적 활동
- 납기 준수, 예산 준수, 품질 준수로 고품질 제품을 개발하고 고객 만족 및 개발 절차 준수 목표

**<span style="color: red;">핵심 관리 대상(3P)</span>**
- 사람, People: 프로젝트 팀원 + 이해관계자의 협력
- 문제, Problem: 목표달성을 위해 해결해야 할 과제의 분석 및 설계
- 프로세스, Process: 프로젝트의 체계적인 진행 관리

**PMBOK(Project Management Body of Knowledge)**
- 프로젝트 관리 프로세스와 지식 체계
- 단계: 프로젝트 착수 → 프로젝트 계획 → 프로젝트 실행 → 프로젝트 통제 → 프로젝트 종료

#### <span style="color: red;">개발 비용 산정</span>

**하향식 산정 기법**: 유사 경험을 토대로 비용 산정
- 전문가 판단기법: 전문가에게 비용 산정 의뢰
- <span style="color: red;">델파이 기법</span>: 회의로 여러 전문가 의견을 종합하여 비용 산정

**상향식 산정 기법**: 세부 작업 단위별로 비용 산정 후 합산
- <span style="color: red;">원시 코드 라인 수(LoC)</span>: (낙관치 + (4 * 중간치) + 비관치) / 6
- 개발 단계별 노력 기법: LoC 기법 확장해서 모든 개발 단계의 비용 합산

**수학적 산정 기법**
- <span style="color: red;">COCOMO</span>: LoC 기반으로 규모예측 후 sw 유형 별 비용 산정 공식 적용
  - 조직형: 5만 라인 이하, 업무용 sw
  - 반분리형: 30만 라인 이하, 운영체제 또는 DBMS
  - 내장형: 30만 라인 이상, 대규모 복잡 sw
- <span style="color: red;">Putnam</span>: Rayleigh-Norden 곡선(시간에 따른 노력 분포 표현)으로 노력 예측하는 모델
  - SLIM: Rayleigh-Norden 곡선과 Putnam 예측 모델 기반으로 한 자동화 추정 도구

**기능 점수 기법, FP**: 기능 개수 기준으로 규모 측정

- 기능 분류
  ```
  기능분류
  ├── 데이터 기능
  │   ├── 내부 논리 파일 (ILF)
  │   └── 외부 연계 파일 (EIF)
  └── 트랜젝션 기능
      ├── 외부 입력 (EI)
      ├── 외부 출력 (EO)
      └── 외부 조회 (EQ)
  ```
- 산정 요소
  - 자료 입력: 입력되는 데이터의 양식 및 복잡도
  - 자료 출력: 출력 보고서의 양식 및 복잡도
  - 명령어: 요청하는 질의 종류 및 복잡도
  - 데이터 파일: 관리하는 데이터 파일의 복잡도 및 관련성
  - 외부 인터페이스: 외부 루틴과 인터페이스 평가

#### 개발 일정 산정

일정계획 작업 순서(형식): 작업 분해(WBS) → 작업 순서/의존성 정의(PERT/CPM 네트워크 차트) → 최소 소요기간 계산(임계경로 산정) → M/M 및 기간산정 후 CPM 수정 → 전체 일정 시각적 표현(간트차트)
- WBS: 목표 달성을 위한 활동 및 업무를 기능 단위로 세분화
- <span style="color: red;">PERT/CPM</span>: 작업 선/후행 관계를 고려해서 전체 작업의 완료 시간을 결정함
- 임계경로(Critical Path): 프로젝트 완료를 위해 필요한 최소 소요 기간
- 간트차트(Gantt Chart): 업무별 시작/종료 시점을 바 형태로 표시

### 요구사항 분석

#### 현행 시스템 분석

##### 단계

현행 시스템 파악 → 플랫폼 기능 분석 → 현행 시스템 분석 → 미들웨어 분석

##### 현행 시스템 파악

기존 시스템의 기능, 성능, 문제점을 이해하고 신규 시스템의 개선, 유지, 변경 부분을 파악함

##### 플랫폼 기능 분석
- 연결 기능: 연결 장소 제공으로 다양한 교류 촉진
- 비용 감소 기능: 그룹간 처리 시간과 비용 절감
- 브랜드 신뢰 기능: 플랫폼 브랜드로 신뢰감 및 품질 보장
- 커뮤니티 형성: 그룹간 상호작용
<span style="color: red;">CPND(Contents → Platform → Network → Device)</span>: 컨텐츠를 플랫폼에 맞게 가공하고 네트워크를 통해 단말기로 서비스를 제공함, 가치사슬 표현 용어

##### 현행 시스템 분석

- 운영체제 분석
- 네트워크 분석
- DBMS 분석

##### <span style="color: red;">미들웨어 분석</span>

양쪽 시스템을 연결하여 데이터를 교환할 수 있도록 중간 매개 역할을 하는 SW
- <span style="color: red;">원격 프로시저 호출</span> 클라이언트가 네트워크를 통해 원격으로 동작하는 프로시저 호출
- <span style="color: red;">메시지 지향 미들웨어(MOL, Message Oriented Middleware</span> 비동기식 미들웨어, 클라이언트가 생성한 메시지를 비동기적으로 저장소에 저장하면서 다른 작업 처리 가능, 실시간 처리에 적합하지 않음
- <span style="color: red;">ORB(Object Request Broker</span> 객체지향 시스템 사이에서 객체/서비스를 요청하면 결과 리턴을 지원함, 오버로딩과 유사
- <span style="color: red;">DB 접속 미들웨어</span> (ex. JDBC, ODBC) 애플리케이션과 DB 서버 간 데이터 접근을 용이하게 연결함
- <span style="color: red;">TP 모니터(Transaction Processing Monitor</span> 분산 시스템에서 트랜젝션 처리를 감시하고 제어함
- <span style="color: red;">엔터프라이즈 서비스 버스(Enterprise Service Bus</span> 메시지 기반으로 느슨한 결합 형태의 표준 인터페이스 통신을 지원, 기업 내외부 모든 시스템을 연동함

#### 요구공학

SW 요구사항을 식별/분석/문서화/관리 하는 과정
프로세스: 요구사항 도출 → 분석 → 명세 → 확인

##### 요구사항 도출

사용자 및 이해관계자의 요구사항 수집(인터뷰, 설문조사, 브레인스토밍, 워크샵 등)

##### 요구사항 분석

충돌하는 부분 수정, 현실성 검토, 우선순위 설정

##### 요구사항 명세

**명세 기법**
- <span style="color: red;">정형 명세 기법</span> 수학적 기호로 표기, 논리학 중심, 명세 오류 및 모호성 파악 유리
- <span style="color: red;">비정형 명세 기법</span> 자연어 및 그림으로 표기, 의사소통 용이

**요구사항 분류**
- <span style="color: red;">기능 요구사항</span> 기능, 서비스 정의
- <span style="color: red;">비기능 요구사항</span> 품질 특성, 제약사항 정의

##### 요구사항 분석 도구
**<span style="color: red;">CASE(Computer Aided SW Engineering)</span>**: 요구사항 자동 분석 및 분석 명세서 작성 도구
- <span style="color: red;">상위 CASE</span>: 계획, 분석, 설계, 기획 단계 지원 (ex. 자료 흐름도 작성 도구)
- <span style="color: red;">하위 CASE</span> 구현(코드 작성), 테스트, 문서화 지원 (ex. 구문 편집기, 코드 생성기)
- <span style="color: red;">통합 CASE</span> 전반적인 sw 생명주기 통합 관리/운영 지원

**<span style="color: red;">HIPO(Hierarchical Input Process Output)</span>**: 하향식 SW 개발을 위한 문서화 도구
- 구성요소
	- 주요 프로세스: 시스템 내에서 주요 기능을 수행하는 프로세스
	- 하위 프로세스: 주요 프로세스를 구성하는 하위 세부 기능의 프로세스 단위
	- 입력/출력: 각 프로세스에 필요한 입출력 표현으로 데이터 흐름 파악
- HIPO Chart 종류
	- <span style="color: red;">가시적 도표</span> 시스템 전체 기능과 흐름을 계층(Tree) 구조로 표현
	- <span style="color: red;">총체적 도표</span> 프로그램을 구성하는 기능과 전반적인 정보 제공
	- <span style="color: red;">세부적 도표</span>: 기능을 구성하는 세부 요소를 상세히 기술한 도표

#### 요구사항 분석 모델링

복잡한 시스템을 효과적으로 이해하고 개발하기 위해 간단한 모델로 표현하는 과정

##### 모델링 구분

- 기능적 모델링: 사용자 관점에서 시스템의 기능 표현 (ex. 사용사례 다이어그램)
- 정적 모델링: 시스템의 구조를 클래스 단위로 표현 (ex. 클래스 다이어그램)
- 동적 모델링: 시스템의 상호작용 및 동작 표현 (ex. 순서 다이어그램)

##### 구조적 분석 도구

- <span style="color: red;">자료 흐름도(DFD, Data Flow Diagram)</span>: 자료의 이동 및 처리 과정을 도형으로 표시, 기능 중심 모델링
	- 처리과정(Process): 자료 변환/처리 과정
	- 자료 흐름(Data flow): 시스템 내 자료 이동 흐름
	- 자료 저장소(Data Store): 자료가 저장되는 파일, DB 표현
	- 단말(Terminator): 입출력 주체(사용자, 외부 시스템) 표시

![DFD](/assets/img/2025-03-07-정보처리기사실기-part1/dfd.png)

- <span style="color: red;">자료사전(DD, Data Dictionary)</span>: DFD에 기술된 자료의 정의 및 설명 제공

| 기호     | 의미     | 설명                      |
| ------ | ------ | ----------------------- |
| =      | 자료의 정의 | 자료의 구성요소 표현             |
| +      | 자료의 연결 | 자료의 순차적 결합 상태 표현        |
| ( )    | 자료의 생략 | 필요에 따라 생략가능한 자료 표현      |
| [ \| ] | 자료의 선택 | 대안 중 하나를 선택할 수 있는 자료 표현 |
| { }    | 자료의 반복 | 자료가 반복될 수 있음을 표현        |
| **     | 자료의 설명 | 주석(추가 설명)               |

> (예시) 회원정보 = 회원정보 + 회원성명 + [전화번호 \| 휴대폰번호] + (집주소)

- <span style="color: red;">MiniSpec</span>: DFD의 각 처리의 수행 업무를 상세히 작성한 문서
- <span style="color: red;">개체 관계도(ERD, Entity Relationship Diagram)</span>: 주로 DB에서 개체, 속성, 개체간 관계를 도식화하는 도구

![ERD](/assets/img/2025-03-07-정보처리기사실기-part1/erd.png)

- <span style="color: red;">상태전이도(STD, State Transition Diagram)</span>: 시스템 상태와 상태 간 전이를 모델화하는 도구

##### 객체지향 분석 방법론

-  <span style="color: red;">럼바우(Rumbaugh) 방법</span>: <span style="color: red;">객체 모델링 → 동적 모델링 → 기능 모델링</span>으로 나눠서 분석하는 기본적인 방법
	- 객체 모델링: <span style="color: red;">객체 다이어그램</span>으로 시스템 객체, 속성, 연산, 관계 표현
	- 동적 모델링: <span style="color: red;">상태 다이어그램</span>으로 시간에 따른 객체 행동 및 상호작용 표현
	- 기능 모델링: <span style="color: red;">DFD</span>로 데이터 흐름, 처리과정 표현
- 부치(Booch) 방법: 미시적/거시적 개발 프로세스 모두 사용, 시스템 구조와 행동을 상세히 표현
- Jacobson 방법: 유즈케이스 중심으로 요구사항과 시스템 간 상호작용을 분석
- Coad Yourdon 방법: E-R 다이어그램으로 객체 행위 모델링
- Wirfs-Brock 방법: 분석과 설계의 명확한 구분 없이 연속적으로 작업 수행

## Ch3. 소프트웨어 설계

### 소프트웨어 설계의 기본 원칙

#### 소프트웨어 설계

**설계 종류**
- 상위 설계
	- 아키텍쳐 설계: 시스템 전반적인 구조 설계
	- 데이터 설계 : 시스템에 필요한 정보 및 DB구조 설계
	- 인터페이스 정의 : 시스템 구조 간, 서브시스템 간 인터페이스 정의
	- 사용자 인터페이스 설계: 사용자 편의를 고려해서 상호작용 인터페이스 설계
- 하위 설계
	- 모듈 설계: 모듈 내부 명세, 알고리즘으로 구체화
	- 자료구조 설계: 데이터 저장 구조, 변수 등 상세 정보 설계
	- 알고리즘 설계: 처리 절차와 알고리즘 설계

**설계 원리**
- 분할과 정복: 큰 SW를 작은 서브시스템으로 나눠서 개발 계획
- 추상화: 공통의 성질을 묶어서 핵심적인 요소로 단순화 함
	- 과정 추상화 기법: 상위 수준에서 수행 흐름만 설계
	- 데이터 추상화 기법: 데이터 구조를 단순하게 표현
	- 제어 추상화 기법: 명령어를 단순하게 표현
- 단계적 분해: 기능을 세부화해서 단계적으로 설계, 복잡성 관리 (구현에 초점을 둔 분할과 정복)
- 모듈화: 개발가능한 독립적 모듈로 분리 (독립적인 개발/테스트/유지, 재사용에 유리)
- <span style="color: red;">정보 은닉</span>: 외부에서 내부 정보의 직접 접근을 제한하여 데이터/기능 보호함(≒ 캡슐화)
- 결합도, 응집도: 좋은 설계는 <span style="color: red;">결합도↓ 응집도↑</span>, 모듈간 독립성과 기능 집중성 유지

#### 설계 모델링

SW 구조와 기능을 그래픽적으로 표현하여 공통된 이해를 도움

##### 설계 모델링 유형

- <span style="color: red;">구조(정적) 모델링</span> 시스템 구성요소와 그 사이 구조적 관계를 표현, <span style="color: red;">UML 정적 다이어그램</span> 활용
- <span style="color: red;">행위(동적) 모델링</span> SW 구성요소의 기능 수행 순서와 방식을 표현, 구성요소간 동적 상호작용 표현, <span style="color: red;">UML 동적 다이어그램</span> 활용

##### 설계 절차 및 유형

| 순서  | 유형            | 산출물       | 설명                                       |
| --- | ------------- | --------- | ---------------------------------------- |
| 1   | 아키텍쳐 설계       | 시스템 아키텍쳐  | 전체 시스템과 서브시스템 간 관계 설계                    |
| 2   | 데이터베이스 설계     | 데이터베이스 명세 | 데이터 구조 설계, 데이터 관리의 일관성 확보                |
| 3   | 서브시스템 설계      | 서브시스템 명세  | 서비스스템의 기능/제약사항 명세, 시스템 기능을 독립적이고 명확하게 정의 |
| 4   | 컴포넌트 설계       | 컴포넌트 명세   | 각 기능별 컴포넌트 설계, 컴포넌트간 인터페이스 정의            |
| 5   | 자료구조와 알고리즘 설계 | 구현        | 데이터 저장 방식, 기본 연산 방법 설계                   |

*요구사항 명세 기반으로 아키텍쳐/데이터베이스 설계 진행*

**<span style="color: red;">협약에 의한 설계</span>**: 클래스의 조건을 명세해서 시스템간 안정성 유지를 목적으로 함

- <span style="color: red;">선행조건</span>: 컴포넌트  오퍼레이션 사용 전 "참"이 되어야 하는 조건
- <span style="color: red;">결과조건</span>: 컴포넌트 오퍼레이션 사용 후 "만족"해야 하는 조건
- <span style="color: red;">불변조건</span>: 오퍼레이션 실행되는 동안 항상 "만족"해야 하는 조건

### 소프트웨어 아키텍처

#### SW 아키텍처

시스템의 기본 구조(골격), 고수준의 설계 지침 제공, 개발 방향성 제시

**SW 아키텍처 특징(원칙)**

- 간략성: 이해/추론이 쉽도록 간결하게 유지
- 추상화: 전반 구조를 추상화
- 가시성: 포함되어야 하는 모든 요소를 명확하게 시각적 표현
- 관점 모형: 다양한 이해당사자의 관심사에 따른 여러 모형을 제시하여 접근성 높임 (ex. 4+1 뷰)
- 의사소통 수단: 이해당사자 간 의사소통 수단으로 활용

**SW 아키텍처 프레임워크 구성요소**

- 아키텍처 명세서
- 이해관계자
- 관심사
- 관점
- <span style = "color:red;">뷰: 이해관계자들의 견해를 반영하여 전체 시스템을 구성하고 표현함</span>

**4 + 1 View Model**

*4: SW 구현의 4가지 관점 / 1: 사용자 관점*

![4+1 View Model](/assets/img/2025-03-07-정보처리기사실기-part1/4-1-view.png)

- 논리뷰(Logical View): 설계자가 사용자 관점에서 시스템의 기능적 요구사항을 표현
- 구현뷰(Implementation View): 개발자가 SW 모듈 구성과 컴포넌트 다이어그램으로 구현 구조 표현
- 프로세스뷰(Process View): 시스템 통합 담당자가 프로그램 실행 시 시스템 상태, 동적 측면(동시성, 분산처리, 시스템 통합)을 표현
- 배치뷰(Deployment View): 시스템 엔지니어가 시스템의 물리적 배치, 네트워크 연결 뿐만 아니라 비기능적 요구사항(성능, 가용성, 신뢰성 등)을 표현
- 유즈케이스 뷰(Use Case View): 아키텍쳐 설계 및 검증 주도, 4개의 뷰 검증 용도

#### 소프트웨어 아키텍처 패턴

공통적인 설계 문제에 대한 일반적인 접근 방법을 제시함

**중요성**

- 재사용성: 검증된 설계 방식을 재사용하여 개발 공수 절감
- 표준화: 표준화된 방식으로 설계하여 일관성↑ 유지보수성↑
- 개발 효율성: 일반적인 문제의 검증된 해결책을 제공하여 개발속도↑
- 문서화: 아키텍처 패턴은 이미 문서화되어 있어 구조를 쉽게 이해하고 공유할 수 있음

**<span style="color:red">SW 아키텍처 패턴 종류</span>**

| 유형                    | 설명                                                | 장점                           | 예시                          |
| --------------------- | ------------------------------------------------- | ---------------------------- | --------------------------- |
| 계층화 패턴                | 소프트웨어를 여러 계층으로 구분, 각 계층이 하위 계층의 기능을 사용하는 구조       | 계층간 독립성 유지보수 성 업그레이드         | OSI 7계층                     |
| 클라이언트-서버 패턴           | 서버가 여러 클라이언트의 서비스를 제공하는 구조, 요청과 응답                | 데이터관리,자원의 효율적인 활용            | 중앙 집중식 데이터 관리               |
| 마스터-슬레이브 패턴           | 마스터 컴포넌트가 작업을 슬레이브에 분산 시키면,슬레이브가 처리 결과를 마스터의 전달함  | 복잡한 작업에 처리 속도 향상             | 고성능 컴퓨팅 환경, 병렬 컴퓨팅          |
| 파이프-필터 패턴             | 데이터 스트림 처리 시스템에서<br>- 단계별 처리: 필터<br>- 결과 전달: 파이프  | 시스테 확장성, 재사용성 향상             | Unix 쉘 스크립트, 데이터 스트림 처리 시스템 |
| 브로커 패턴                | 분산시스템에서 컴포넌트간 통신(요청/처리결과)을 중재하는 브로커 컴포넌트를 사용하는 구조 | 시스템 유연성, 확장성 향상              | ORB 미들웨어, 오버로딩              |
| <span style="color:red">피어 투 피어 패턴</span>        | 모든 컴포넌트(피어)가 서버와 클라이언트 역할을 동시수행하는 구조              | 중앙집중식 서버에 의존하지 않는 분산 네트워크 구조 | 파일 공유시스템                    |
| 이벤트-버스 패턴             | 이벤트 버스로 메시지 발생하면 리스너가 구독하는 구조                     | 이벤트 기반 비동기 통신                | 메시징/알림 시스템                  |
| <span style="color:red">모델-뷰-컨트롤러 패턴(MVC)</span> | 모델(데이터 처리) + 뷰(UI) + 컨트롤러(입력 처리)로 구성              | 컴포넌트간 독립성, 재사용성, 확장성 향상      | 웹 어플리케이션                    |
| 블랙보드 패턴               | 여러 컴포넌트가 공유하는 중앙정보 저장소(블랙보드)를 통한 협업구조             | -                            | 복잡하고 명확한 해결 전략이 정의되지 않았을 때  |
| 인터프리터 패턴              | 특정 프로그래밍 언어의 해석/실행을 위한 컴포넌트 설계에 사용                | -                            | -                           |

### <span style="color:red;">UML</span>
*1문제 출제 예상*

#### UML

SW를 시각화/문서화 시, <span style="color:red;">시스템구조(정적구조)</span>와 <span style="color:red;">동작(동적구조)</span>을 표준화된 언어로 명세하는 모델링 언어

**특징**

- 가시화 언어: 시스템구조와 동작을 시각화하여 쉽게 이해
- 명세화 언어: 표준화된 언어로 요구사항/기능 명세
- 구축 언어: UML 기반으로 구현 진행됨
- 문서화 언어: 커뮤니케이션 및 산출물로 활용

#### <span style="color:red;">구성요소: 사물/관계/다이어그램</span>

**사물(Thing)**

- <span style="color:red;">구조사물</span>: 시스템의 개념적, 물리적 요소 표현 (ex. 클래스, 유스케이스, 컴포넌트 등)
- <span style="color:red;">행동사물</span>: 시공간에 따라 변화하는 요소들의 행위 표현 (ex. 상호작용, 상태머신 등)
- 그룹사물: 요소를 그룹으로 묶어서 표현 (ex. 패키지)
- 주해사물: 부가 설명, 제약조건 (ex. 주석)

**<span style="color:red;">관계(Relationship)</span>**

| 관계 유형                  | ⭤   | 관계 유형               |
| ---------------------- | --- | ------------------- |
| 일반화 관계(Generalization) | ⭤   | 실체화 관계(Realization) |
| 연관 관계(Association)     | ⭤   | 의존 관계(Dependency)   |
| 집약 관계(Aggregation)     | ⭤   | 합성 관계(Composition)  |

- **일반화 관계(Generalization)**
	- 객체지향 개념에서 <span style="color:red;">상속 관계(Inheritance)</span>, 상위 클래스의 속성과 메서드를 하위클래스가 물려받음
	- *부모(슈퍼)클래스, 자식(서브)클래스 모두 실체화 될 수 있음*

	![일반화 관계](/assets/img/2025-03-07-정보처리기사실기-part1/generalization.png)
- **실체화 관계(Realization)**
	- <span style="color:red;">인터페이스의 추상메서드를 구현 클래스가 상속받아서 오버라이딩(재정의)</span>하는 관계
	- *인터페이스는 추상화, 구현클래스는 실체화 됨*

	![실체화 관계](/assets/img/2025-03-07-정보처리기사실기-part1/realization.png)
- **연관 관계(Association)**
	- <span style="color:red;">한 클래스가 다른 클래스의 기능을 사용</span>할 때, 두 객체가 <span style="color:red;">서로 연관</span>되어 있음을 표현

  ![연관 관계](/assets/img/2025-03-07-정보처리기사실기-part1/association.png)
- **의존 관계(Dependency)**
	- 한 클래스가 다른 클래스의 기능을 일시적으로 사용할 때 관계
	- <span style="color:red;">한 클래스가 다른 클래스를 오퍼레이션의 매개변수로 사용</span>하는 경우
	- 한 클래스의 명세가 변경되면 다른 클래스에 영향을 미침

	![의존 관계](/assets/img/2025-03-07-정보처리기사실기-part1/dependency.png)
- **집약 관계(Aggregation)**
	- <span style="color:red;">한 객체(전체 객체)가 다른 객체(부분 객체)를 소유</span>하는 'has a' 관계이지만, <span style="color:red;">객체간 독립적</span>임
	- *전체 객체가 사라져도 부분 객체는 사라지지 않음*

	![집약 관계](/assets/img/2025-03-07-정보처리기사실기-part1/aggregation.png)
- **합성 관계(Composition)**
	- <span style="color:red;">부분 객체가 전체 객체에 속하는 긴밀/필수적인 관계</span>로, <span style="color:red;">객체간 의존적</span>임
	- *전체 객체가 사라지면 부분 객체도 사라짐*

	![합성 관계](/assets/img/2025-03-07-정보처리기사실기-part1/composition.png)

**다이어그램(Diagram)**

| 구조(정적) 다이어그램                        | 설명                                                                 |
| ----------------------------------- | ------------------------------------------------------------------ |
| 클래스 다이어그램 (Class)                   | - 클래스 및 이들 간의 관계 표현<br>- 데이터 구조와 클래스 간 상속/연관/의존성 표현                |
| 객체 다이어그램 (Object)                   | - 객체 및 이들 간의 관계를 특정 시점에서 시각화 표현                                    |
| 컴포넌트 다이어그램 (Component)              | - 논리적 구성요소(컴포넌트: 모듈의 묶음 단위) 및 이들 간 의존성 표현<br>- 컴포넌트, 인터페이스, 의존성 표현 |
| 배치 다이어그램 (Deployment)               | - 시스템 물리적 배치, 구성요소 간 관계 표현<br>- 하드웨어, 네트워크, SW 구성요소 표현             |
| 복합체 구조 다이어그램 (Complex Constructure) | - 복합구조, 클래스, 컴포넌트의 내부구조 및 상호작용 표현                                  |
| 패키지 다이어그램 (Package)                 | - 패키지, 클래스 간 그룹화 및 관계 시각화                                          |

| 행위(동적) 다이어그램                | 설명                                                                                                             | 예시                                       |
| --------------------------- | -------------------------------------------------------------------------------------------------------------- | ---------------------------------------- |
| 유즈케이스 다이어그램 (Use Case)      | - 시스템의 기능과 사용자 간 상호작용 표현<br>- 요구사항 문서화에 활용<br>- 구성요소: 시스템, 액터, 유즈케이스, 관계                                       | ![유즈케이스 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/usecase-diagram.png)<br><br> |
| 순차 다이어그램 (Sequence)         | - 시간 순서에 따라 객체 간 상호작용(by 메시지) 표현<br>- 구성요소: 활성객체, 메시지, 생명선, 활성 박스<br>- 메시지 유형: 동기 메시지, 비동기 메시지, 반환 메시지, 자체 메시지 | ![순차 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/sequence-diagram.png)<br><br> |
| 커뮤니케이션 다이어그램(Communication) | 객체 간 상호작용과 통신 표현                                                                                               | ![커뮤니케이션 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/communication-diagram.png)         |
| 상태 다이어그램 (State)            | 객체 생명주기동안 외/내부 이벤트에 의한 상태 변화 표현                                                                                | ![상태 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/state-diagram.png)<br><br> |
| 활동 다이어그램 (Activity)         | - 시스템의 프로세스, 워크플로우 표현<br>- 비즈니스 프로세스 모델링                                                                       | ![활동 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/activity-diagram.png)         |
| 상호작용 다이어그램(Interaction)     | - 시스템의 상호작용을 워크플로우로 표현<br>- 활동 다이어그램 + 순차 다이어그램                                                                | ![상호작용 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/interaction-diagram.png)         |
| 타이밍 다이어그램(Timing)           | - 객체 행동/시간에 따른 상태 변화, 상호작용 표현<br>- 시간에 따른 타이밍에 초점                                                              | ![타이밍 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/timing-diagram.png)         |

#### 주요 다이어그램

**클래스 다이어그램**

| 접근제한자     | 표기법 | 사용 범위              |
| --------- | --- | ------------------ |
| public    | +   | 어디서든 접근 가능         |
| protected | \#  | 상속, 동일 패키지 내 접근 가능 |
| public    | -   | 동일 클래스 내 접근 가능     |

**유즈케이스 다이어그램**

| 구성요소  | 설명                       |
| ----- | ------------------------ |
| 시스템   | 개발 대상 시스템                |
| 액터    | 시스템과 상호작용하는 사람 또는 외부 시스템 |
| 유즈케이스 | 사용자 입장에서 시스템의 주요 기능      |
| 관계    | 액터와 유즈케이스 간 관계 표현        |

- 연관 관계(Association): 유즈케이스와 액터 간 관계

  ![연관 관계](/assets/img/2025-03-07-정보처리기사실기-part1/usecase-diagram-association.png)
- 포함 관계(Include): 특정 유즈케이스 수행에 반드시 포함되어 실행되는 다른 유즈케이스

  ![포함 관계](/assets/img/2025-03-07-정보처리기사실기-part1/usecase-diagram-include.png)
- 확장 관계(Extend): 유즈케이스 수행 중 조건에 따라 확장 기능이 실행되는 경우

  ![확장 관계](/assets/img/2025-03-07-정보처리기사실기-part1/usecase-diagram-extend.png)
- 일반화 관계(Generalization): 유사 유즈케이스, 액터를 추상화하여 상위 개념으로 묶어 표현

  ![일반화 관계](/assets/img/2025-03-07-정보처리기사실기-part1/usecase-diagram-generalization.png)

**시퀀스(순차) 다이어그램**

![시퀀스 다이어그램 메시지](/assets/img/2025-03-07-정보처리기사실기-part1/sequence-diagram-message.png)

## Ch4.  화면 설계

### UI 설계

#### UI(User Interface) 개념

**UI**

User Interface, 기기와 사용자 간 상호작용이 가능한 매개체

**UX**

User Experience, 사용자가 UI를 통해 경험한 모든 요소

**<span style="color:red;">UI 유형</span>**

| 유형                                     | 설명                               |
| -------------------------------------- | -------------------------------- |
| CLI(Command Line Interface)            | 명령어를 입력해서 조작하는 방식                |
| GUI(Graphic User Interface)            | 그래픽/텍스트 기반으로 사용자 입력을 직관적으로 받는 방식 |
| NUI(Natural User Interface)            | 사용자의 자연스러운 움직임을 인식하여 정보를 제공하는 방식 |
| OUI(Organic User Interface)            | 현실의 모든 요소를 입/출력 장치로 사용하는 방식      |
| VUI(Voice User Interface)              | 사용자의 음성인식 기반 상호작용 방식             |
| ARUI(Augmented Reality User Interface) | 증강 현실 기술을 활용하는 상호작용 방식           |

#### UI 설계

**UI 요구사항 구분**
- 기능적 요구사항: 시스템이 제공해야 하는 기능 (입/출력, 데이터, 연산 등)
- 비기능적 요구사항: 시스템 품질에 대한 요구사항 (사용성, 효울성, 신뢰성, 유지보수성, 재사용성 등)

**설계 절차**

UI 개발 목표/범위 수립 → 전략 수집 → 사용자 요구사항 분석 → UI 상세 설계 → 구현 → 테스트

**<span style="color:red;">UI 설계 원칙</span>**
- 직관성: 누구나 쉽게 이해할 수 있어야 함
- 유효성: 사용자의 목적을 정확하게 달성해야 함
- 학습성: 누구나 쉽게 배울 수 있어야 함
- 유연성: 사용자 요구사항을 최대한 수용하고, 오류를 최소화 해야 함

**UI 설계 도구**
- 와이어프레임: 간략하게 기본 구조, 레이아웃을 표현하는 초기 설계 도구
- 스토리보드: 시나리오 흐름을 시각적으로 표현, 인터렉션 세부화
- 프로토타입: 실제 서비스와 유사하게 동작하는 모델
- 목업: 와이어프레임보다 구체적으로 실제 화면과 유사한 정적 디자인
- 유스케이스: 사용자 관점에서 목표달성을 위한 동작 사니라오 기술

#### 감성공학
- 인간 감정을 물리적 설계요소로 번역/구현하는 기술
- 단계: 요소화 → 형상화 → 구현 → 생산

**감성 종류 및 감성공학 접근 방법**

| 감성공학 접근 방법 | 인간 감성 종류 | 설명                         |
| ---------- | -------- | -------------------------- |
| 1류 접근 방법   | 감각적 감성   | 제품에 대한 이미지 분석해서 디자인 요소와 연결 |
| 1류 접근 방법   | 기능적 감성   | 제품 성능 및 사용 편의성을 디자인 요소와 연결 |
| 2류 접근 방법   | 문화적 감성   | 사회/문화로 형성된 감성을 제품에 적용      |
| 3류 접근 방법   | -        | 감성을 정량화하여 제품설계에 적용         |
