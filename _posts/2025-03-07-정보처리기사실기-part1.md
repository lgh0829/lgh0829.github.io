---
title: 정보처리기사 실기 PART1. 소프트웨어 구축
description: 소프트웨어 구축 이론 정리
author: GH Lee
date: 2025-03-07 00:00:00 +0900
categories: [License]
tags: [License, Note]
pin: false
math: false
mermaid: false
---
## Ch1. 소프트웨어 공학 개념

### 소프트웨어 공학
품질 높은 소프트웨어를 효율적으로 개발하기 위한 방법, 도구, 이론

#### 3R : 역공학, 재공학, 재사용

##### 역공학(Reverse Engineering)
이미 개발된 시스템의 소스코드에 기반하여 문서(설계명세서, 요구분석서)를 역산출하는 방식

##### 재공학(Re-Engineering)
- 기존 소프트웨어를 개선, 유지보수하여 생산성 위기를 해결하는 방식
- 과정: 분석 - 재구성 - 역공학 - 이관
  - 분석: 기존 소프트웨어를 검토하여 재공학 대상을 선정
  - 재구성: 소프트웨어 구조개선 목적으로 코드를 재구성하되, 외적 기능은 변경하지 않음
  - 역공학: 소프트웨어 소스코드를 분석해서 설계 수준 도출
  - 이관: 다른 운영체제, 프레임워크에서 사용할 수 있도록 소프트웨어 변환 작업

##### 재사용(Reuse)
- 기존 소프트웨어의 전체 또는 일부를 다시 사용하는 방식
- 범위
  - 함수, 객체 재사용: 클래스나 함수 단위로 재사용
  - 컴포넌트 재사용: 독립적인 소프트웨어 컴포넌트를 재사용
  - 애플리케이션 재사용: 애플리케이션 전체 또는 일부를 재사용
- 재사용 방법
  - 합성중심(Composition Based, 블록구성): 블록처럼 소프트웨어 부품을 조합해서 전체를 완성
  - 생성중심(Generation Based, 패턴구성): 추상화된 형태의 명세를 구체화하여 특정 패턴을 적용하는 방식으로 프로그램 생성

#### 개발단계
계획 - 요구사항분석 - 설계 - 구현 - 테스트 - 유지보수
- 계획: 개발 내용을 정의하고 비용/기간을 예측해서 프로젝트를 발주하거나 폐기함
- 요구사항분석: 고객의 머리속에 있는 생각을 끄집어내서 구체화
- 구현: 개발 진행(코딩, 디버깅, 단위테스트)
- 테스트: 요구사항대로 구현됐는지 확인
- 유지보수: 프로그램 운영 및 기능 개선

### 소프트웨어 개발 방법론

#### 구조적 방법론
**정의**
- <span style="color: red;">절차지향</span>적인 개발 방법론
- <span style="color: red;">하향식</span>: 사전에 정의된 구조로 코드를 작성하고 순차적으로 실행 (ex. C, Fortran, Cobol)

<span style="color: red;">**구성요소**</span>
- 데이터흐름도 (DFD, Data Flow Diagram): 전체적인 데이터 흐름 표현
- 데이터사전 (DD, Data Dictionary): 시스템에서 사용되는 데이터 세부사항을 문서화
- 상태전이도 (STD, State Transition Diagram): 시스템이 동작에 의한 상태의 변화를 모델링
- 소단위명세서(Minispec): 모듈의 기능과 로직을 상세히 설명
- ERD(Entity Relationship Diagram): DB 구조를 설명

#### 정보공학 방법론
**정의**
- 기업 내부 데이터 중심 접근 방식으로 sw개발을 넘어 기업경영전략에 초점
- 계획, 분석, 설계, 구축에 정형화된 기법을 적용

#### 객체지향 방법론
**정의**
- 모든 유무형을 객체화하는 개발 방법론
- 상향식: 객체와 클래스간의 관계를 식별하고 이를 설계 모델로 변환 (ex. JAVA, Javascript, Python)

##### <span style="color: red;">구성요소: 객체(인스턴스), 클래스, 속성, 메서드, 메시지</span>
- 클래스: 틀
- 속성
- 메서드: 연산
- 객체(인스턴스): 클래스를 통해 실체화된 것
- 메시지: 객체간 소통 수단

![객체지향 방법론 구성요소](/assets/img/2025-03-07-정보처리기사실기-part1/oop-component.png)

##### 특징
- 정보은닉: 내부구조를 외부로부터 숨겨서 안정성 높임
- 캡슐화: 의사소통을 위해 특정 인터페이스를 제공해서 외부로부터 직접 접근을 막음
- 상속: 재사용과 확장성을 위해 기존 클래스의 속성을 받아서 새로운 클래스를 작성하는 기법 (부모 클래스로부터 자식 클래스가 속성을 물려받는 것)
- 추상화: 공통된 성질을 모아서 생산, 유지보수 효율성 증가
- 다형성: 하나의 인터페이스로 다양한 형태의 구현을 가지는 방식
  - 오버로딩: 동일한 메서드에 입력하는 인자 개수, 타입에 따라 서로 다른 결과값을 가지는 방식
  - 오버라이딩: 상속 받은 메서드를 재정의하는 방식

#### CBD(Component Based Development) 방법론
**정의**
- 재사용가능한 컴포넌트를 개발하거나 상용 컴포넌트를 조합해서 어플리케이션 개발
- 확장성이 좋아 새로운 기능 추가에 용이

#### 애자일(Agile) 방법론
**정의**
- 변화에 빠르고 유연하게 대응하는 개발방식
- 소프트웨어 개발의 민첩성과 효율성을 강조

**종류**
- XP(Extreme Programming): 반복적이고 점진적인 개발과 고객의 참여를 반복하여 안정성을 확보하고 개발효율성을 높임
- 스크럼(SCRUM): 유연하고 생산적인 프로젝트 관리 방식을 적용해서 효율적인 협업 지원
- FDD(Feature-Driven Development): 기능 중심 반복적 개발
- Crystal 개발 방식: 프로젝트 크기와 중요도에 따라 최적의 개발방식을 선택

### 소프트웨어 개발 모델

#### 폭포수 모델
- 선형 순차적으로 계획 → 분석 → 설계 → 구현 → 테스트 → 운영 순으로 진행하는 전통적인 개발 모형
- 안정성이 매우 높으며 이전 단계로 돌아가기 어려움

#### 프로토타이핑 모델
- 고객의 요구사항으로 <span style="color: red;">시제품</span>을 만들어 결과를 예측하는 개발 모형

#### 나선형(Spiral) 모델
- 폭포수 모델 + 프로토타이핑 모델
- "계획 수립 → <span style="color: red;">위험 분석</span> → 프로토타이핑 개발 → 고객평가 피드백" 절차를 점진적으로 진행하는 개발 모형

#### RAD(Rapid Application Development) 모델
- CASE 도구를 활용해서 짧은 개발주기내에 개발
- 상위 CASE 도구: 분석, 설계
- 하위 CASE 도구: 개발, 테스트, 문서화

#### V 모델
개발절차에 따라 테스트/검증 절차를 강조한 모델
테스트 단계: 단위테스트 → 통합테스트 → 시스템테스트 → 인수테스트

![V 모델](/assets/img/2025-03-07-정보처리기사실기-part1/v-model.png)

#### 4세대 기법(4th Generation Techniques)
요구사항 명세서 기반으로 코드를 자동 생성하는 기법

### Agile 방법론

#### 개념
짧은 주기 동안 반복 작업을 통해 신속하고 지속적으로 작동가능한 소프트웨어를 개발하는 방식
작은 구성요소를 빠르게 제공하여 변화에 민감하게 대응가능

#### 종류1: XP(Extream Programming)
개발문서보다 소스코드에 중점
고객의 요구사항에 유연하게 대응하기 위해 고객 참여와 짧은 주기 개발 과정을 반복 진행 
5가지 핵심가치: <span style="color: red;">용기, 단순성, 의사소통, 피드백, 중점</span>

#### 종류2: SCRUM
기능개발, 개선에 우선순위 부여해서 개발 집중도 높임
짧은 개발 주기마다 결과물 제공

**용어**
- 제품백로그: 제품 단위 요구기능 목록
- 스프린트: 반복적이고 짧은 개발주기 단위
- 스프린트 계획회의: 스프린트 목표 및 스프린트 백로그 목표 계획 회의
- 스프린트 백로그: 스프린트 목표를 위한 작업 목록
- 스크럼 마스터: 스크럼 프로세스 및 활용을 보장하는 프로젝트 관리자

#### 기타 종류
- Crystal
- FDD(Feature-Driven Development)
- ASD(Adaptive Software Development): 합동 애플리케이션 개발에서 혼란을 규정하고, 혼란에 적응할 수 있는 방법론
- Lean: 낭비요소를 제거하고 품질을 향상시키는 방법론

### Ch2. 프로젝트 계획 및 분석

#### 프로젝트 계획

##### 프로젝트 관리

**개념**
- 한정된 기간, 예산, 자원을 활용하여 사용자에게 만족스러운 제품/서비스를 개발하는 기술·관리적 활동
- 납기 준수, 예산 준수, 품질 준수로 고품질 제품을 개발하고 고객 만족 및 개발 절차 준수 목표

**<span style="color: red;">핵심 관리 대상(3P)</span>**
- 사람, People: 프로젝트 팀원 + 이해관계자의 협력
- 문제, Problem: 목표달성을 위해 해결해야 할 과제의 분석 및 설계
- 프로세스, Process: 프로젝트의 체계적인 진행 관리

**PMBOK(Project Management Body of Knowledge)**
- 프로젝트 관리 프로세스와 지식 체계
- 단계: 프로젝트 착수 → 프로젝트 계획 → 프로젝트 실행 → 프로젝트 통제 → 프로젝트 종료

#### <span style="color: red;">개발 비용 산정</span>

**하향식 산정 기법**: 유사 경험을 토대로 비용 산정
- 전문가 판단기법: 전문가에게 비용 산정 의뢰
- <span style="color: red;">델파이 기법</span>: 회의로 여러 전문가 의견을 종합하여 비용 산정

**상향식 산정 기법**: 세부 작업 단위별로 비용 산정 후 합산
- <span style="color: red;">원시 코드 라인 수(LoC)</span>: (낙관치 + (4 * 중간치) + 비관치) / 6
- 개발 단계별 노력 기법: LoC 기법 확장해서 모든 개발 단계의 비용 합산

**수학적 산정 기법**
- <span style="color: red;">COCOMO</span>: LoC 기반으로 규모예측 후 sw 유형 별 비용 산정 공식 적용
  - 조직형: 5만 라인 이하, 업무용 sw
  - 반분리형: 30만 라인 이하, 운영체제 또는 DBMS
  - 내장형: 30만 라인 이상, 대규모 복잡 sw
- <span style="color: red;">Putnam</span>: Rayleigh-Norden 곡선(시간에 따른 노력 분포 표현)으로 노력 예측하는 모델
  - SLIM: Rayleigh-Norden 곡선과 Putnam 예측 모델 기반으로 한 자동화 추정 도구

**기능 점수 기법, FP**: 기능 개수 기준으로 규모 측정

- 기능 분류
  ```
  기능분류
  ├── 데이터 기능
  │   ├── 내부 논리 파일 (ILF)
  │   └── 외부 연계 파일 (EIF)
  └── 트랜젝션 기능
      ├── 외부 입력 (EI)
      ├── 외부 출력 (EO)
      └── 외부 조회 (EQ)
  ```
- 산정 요소
  - 자료 입력: 입력되는 데이터의 양식 및 복잡도
  - 자료 출력: 출력 보고서의 양식 및 복잡도
  - 명령어: 요청하는 질의 종류 및 복잡도
  - 데이터 파일: 관리하는 데이터 파일의 복잡도 및 관련성
  - 외부 인터페이스: 외부 루틴과 인터페이스 평가

#### 개발 일정 산정

일정계획 작업 순서(형식): 작업 분해(WBS) → 작업 순서/의존성 정의(PERT/CPM 네트워크 차트) → 최소 소요기간 계산(임계경로 산정) → M/M 및 기간산정 후 CPM 수정 → 전체 일정 시각적 표현(간트차트)
- WBS: 목표 달성을 위한 활동 및 업무를 기능 단위로 세분화
- <span style="color: red;">PERT/CPM</span>: 작업 선/후행 관계를 고려해서 전체 작업의 완료 시간을 결정함
- 임계경로(Critical Path): 프로젝트 완료를 위해 필요한 최소 소요 기간
- 간트차트(Gantt Chart): 업무별 시작/종료 시점을 바 형태로 표시

### 요구사항 분석

#### 현행 시스템 분석

##### 단계

현행 시스템 파악 → 플랫폼 기능 분석 → 현행 시스템 분석 → 미들웨어 분석

##### 현행 시스템 파악

기존 시스템의 기능, 성능, 문제점을 이해하고 신규 시스템의 개선, 유지, 변경 부분을 파악함

##### 플랫폼 기능 분석
- 연결 기능: 연결 장소 제공으로 다양한 교류 촉진
- 비용 감소 기능: 그룹간 처리 시간과 비용 절감
- 브랜드 신뢰 기능: 플랫폼 브랜드로 신뢰감 및 품질 보장
- 커뮤니티 형성: 그룹간 상호작용
<span style="color: red;">CPND(Contents → Platform → Network → Device)</span>: 컨텐츠를 플랫폼에 맞게 가공하고 네트워크를 통해 단말기로 서비스를 제공함, 가치사슬 표현 용어

##### 현행 시스템 분석

- 운영체제 분석
- 네트워크 분석
- DBMS 분석

##### <span style="color: red;">미들웨어 분석</span>

양쪽 시스템을 연결하여 데이터를 교환할 수 있도록 중간 매개 역할을 하는 SW
- <span style="color: red;">원격 프로시저 호출</span> 클라이언트가 네트워크를 통해 원격으로 동작하는 프로시저 호출
- <span style="color: red;">메시지 지향 미들웨어(MOL, Message Oriented Middleware</span> 비동기식 미들웨어, 클라이언트가 생성한 메시지를 비동기적으로 저장소에 저장하면서 다른 작업 처리 가능, 실시간 처리에 적합하지 않음
- <span style="color: red;">ORB(Object Request Broker</span> 객체지향 시스템 사이에서 객체/서비스를 요청하면 결과 리턴을 지원함, 오버로딩과 유사
- <span style="color: red;">DB 접속 미들웨어</span> (ex. JDBC, ODBC) 애플리케이션과 DB 서버 간 데이터 접근을 용이하게 연결함
- <span style="color: red;">TP 모니터(Transaction Processing Monitor</span> 분산 시스템에서 트랜젝션 처리를 감시하고 제어함
- <span style="color: red;">엔터프라이즈 서비스 버스(Enterprise Service Bus</span> 메시지 기반으로 느슨한 결합 형태의 표준 인터페이스 통신을 지원, 기업 내외부 모든 시스템을 연동함

#### 요구공학

SW 요구사항을 식별/분석/문서화/관리 하는 과정
프로세스: 요구사항 도출 → 분석 → 명세 → 확인

##### 요구사항 도출

사용자 및 이해관계자의 요구사항 수집(인터뷰, 설문조사, 브레인스토밍, 워크샵 등)

##### 요구사항 분석

충돌하는 부분 수정, 현실성 검토, 우선순위 설정

##### 요구사항 명세

**명세 기법**
- <span style="color: red;">정형 명세 기법</span> 수학적 기호로 표기, 논리학 중심, 명세 오류 및 모호성 파악 유리
- <span style="color: red;">비정형 명세 기법</span> 자연어 및 그림으로 표기, 의사소통 용이

**요구사항 분류**
- <span style="color: red;">기능 요구사항</span> 기능, 서비스 정의
- <span style="color: red;">비기능 요구사항</span> 품질 특성, 제약사항 정의

##### 요구사항 분석 도구
**<span style="color: red;">CASE(Computer Aided SW Engineering)</span>**: 요구사항 자동 분석 및 분석 명세서 작성 도구
- <span style="color: red;">상위 CASE</span>: 계획, 분석, 설계, 기획 단계 지원 (ex. 자료 흐름도 작성 도구)
- <span style="color: red;">하위 CASE</span> 구현(코드 작성), 테스트, 문서화 지원 (ex. 구문 편집기, 코드 생성기)
- <span style="color: red;">통합 CASE</span> 전반적인 sw 생명주기 통합 관리/운영 지원

**<span style="color: red;">HIPO(Hierarchical Input Process Output)</span>**: 하향식 SW 개발을 위한 문서화 도구
- 구성요소
	- 주요 프로세스: 시스템 내에서 주요 기능을 수행하는 프로세스
	- 하위 프로세스: 주요 프로세스를 구성하는 하위 세부 기능의 프로세스 단위
	- 입력/출력: 각 프로세스에 필요한 입출력 표현으로 데이터 흐름 파악
- HIPO Chart 종류
	- <span style="color: red;">가시적 도표</span> 시스템 전체 기능과 흐름을 계층(Tree) 구조로 표현
	- <span style="color: red;">총체적 도표</span> 프로그램을 구성하는 기능과 전반적인 정보 제공
	- <span style="color: red;">세부적 도표</span>: 기능을 구성하는 세부 요소를 상세히 기술한 도표

#### 요구사항 분석 모델링

복잡한 시스템을 효과적으로 이해하고 개발하기 위해 간단한 모델로 표현하는 과정

##### 모델링 구분

- 기능적 모델링: 사용자 관점에서 시스템의 기능 표현 (ex. 사용사례 다이어그램)
- 정적 모델링: 시스템의 구조를 클래스 단위로 표현 (ex. 클래스 다이어그램)
- 동적 모델링: 시스템의 상호작용 및 동작 표현 (ex. 순서 다이어그램)

##### 구조적 분석 도구

- <span style="color: red;">자료 흐름도(DFD, Data Flow Diagram)</span>: 자료의 이동 및 처리 과정을 도형으로 표시, 기능 중심 모델링
	- 처리과정(Process): 자료 변환/처리 과정
	- 자료 흐름(Data flow): 시스템 내 자료 이동 흐름
	- 자료 저장소(Data Store): 자료가 저장되는 파일, DB 표현
	- 단말(Terminator): 입출력 주체(사용자, 외부 시스템) 표시

![DFD](/assets/img/2025-03-07-정보처리기사실기-part1/dfd.png)

- <span style="color: red;">자료사전(DD, Data Dictionary)</span>: DFD에 기술된 자료의 정의 및 설명 제공

| 기호   | 의미        | 설명                                    |
| ------ | ----------- | --------------------------------------- |
| =      | 자료의 정의 | 자료의 구성요소 표현                    |
| +      | 자료의 연결 | 자료의 순차적 결합 상태 표현            |
| ( )    | 자료의 생략 | 필요에 따라 생략가능한 자료 표현        |
| [ \| ] | 자료의 선택 | 대안 중 하나를 선택할 수 있는 자료 표현 |
| { }    | 자료의 반복 | 자료가 반복될 수 있음을 표현            |
| **     | 자료의 설명 | 주석(추가 설명)                         |

> (예시) 회원정보 = 회원정보 + 회원성명 + [전화번호 \| 휴대폰번호] + (집주소)

- <span style="color: red;">MiniSpec</span>: DFD의 각 처리의 수행 업무를 상세히 작성한 문서
- <span style="color: red;">개체 관계도(ERD, Entity Relationship Diagram)</span>: 주로 DB에서 개체, 속성, 개체간 관계를 도식화하는 도구

![ERD](/assets/img/2025-03-07-정보처리기사실기-part1/erd.png)

- <span style="color: red;">상태전이도(STD, State Transition Diagram)</span>: 시스템 상태와 상태 간 전이를 모델화하는 도구

##### 객체지향 분석 방법론

-  <span style="color: red;">럼바우(Rumbaugh) 방법</span>: <span style="color: red;">객체 모델링 → 동적 모델링 → 기능 모델링</span>으로 나눠서 분석하는 기본적인 방법
	- 객체 모델링: <span style="color: red;">객체 다이어그램</span>으로 시스템 객체, 속성, 연산, 관계 표현
	- 동적 모델링: <span style="color: red;">상태 다이어그램</span>으로 시간에 따른 객체 행동 및 상호작용 표현
	- 기능 모델링: <span style="color: red;">DFD</span>로 데이터 흐름, 처리과정 표현
- 부치(Booch) 방법: 미시적/거시적 개발 프로세스 모두 사용, 시스템 구조와 행동을 상세히 표현
- Jacobson 방법: 유즈케이스 중심으로 요구사항과 시스템 간 상호작용을 분석
- Coad Yourdon 방법: E-R 다이어그램으로 객체 행위 모델링
- Wirfs-Brock 방법: 분석과 설계의 명확한 구분 없이 연속적으로 작업 수행

## Ch3. 소프트웨어 설계

### 소프트웨어 설계의 기본 원칙

#### 소프트웨어 설계

**설계 종류**
- 상위 설계
	- 아키텍쳐 설계: 시스템 전반적인 구조 설계
	- 데이터 설계 : 시스템에 필요한 정보 및 DB구조 설계
	- 인터페이스 정의 : 시스템 구조 간, 서브시스템 간 인터페이스 정의
	- 사용자 인터페이스 설계: 사용자 편의를 고려해서 상호작용 인터페이스 설계
- 하위 설계
	- 모듈 설계: 모듈 내부 명세, 알고리즘으로 구체화
	- 자료구조 설계: 데이터 저장 구조, 변수 등 상세 정보 설계
	- 알고리즘 설계: 처리 절차와 알고리즘 설계

**설계 원리**
- 분할과 정복: 큰 SW를 작은 서브시스템으로 나눠서 개발 계획
- 추상화: 공통의 성질을 묶어서 핵심적인 요소로 단순화 함
	- 과정 추상화 기법: 상위 수준에서 수행 흐름만 설계
	- 데이터 추상화 기법: 데이터 구조를 단순하게 표현
	- 제어 추상화 기법: 명령어를 단순하게 표현
- 단계적 분해: 기능을 세부화해서 단계적으로 설계, 복잡성 관리 (구현에 초점을 둔 분할과 정복)
- 모듈화: 개발가능한 독립적 모듈로 분리 (독립적인 개발/테스트/유지, 재사용에 유리)
- <span style="color: red;">정보 은닉</span>: 외부에서 내부 정보의 직접 접근을 제한하여 데이터/기능 보호함(≒ 캡슐화)
- 결합도, 응집도: 좋은 설계는 <span style="color: red;">결합도↓ 응집도↑</span>, 모듈간 독립성과 기능 집중성 유지

#### 설계 모델링

SW 구조와 기능을 그래픽적으로 표현하여 공통된 이해를 도움

##### 설계 모델링 유형

- <span style="color: red;">구조(정적) 모델링</span> 시스템 구성요소와 그 사이 구조적 관계를 표현, <span style="color: red;">UML 정적 다이어그램</span> 활용
- <span style="color: red;">행위(동적) 모델링</span> SW 구성요소의 기능 수행 순서와 방식을 표현, 구성요소간 동적 상호작용 표현, <span style="color: red;">UML 동적 다이어그램</span> 활용

##### 설계 절차 및 유형

| 순서 | 유형                     | 산출물            | 설명                                                                    |
| ---- | ------------------------ | ----------------- | ----------------------------------------------------------------------- |
| 1    | 아키텍쳐 설계            | 시스템 아키텍쳐   | 전체 시스템과 서브시스템 간 관계 설계                                   |
| 2    | 데이터베이스 설계        | 데이터베이스 명세 | 데이터 구조 설계, 데이터 관리의 일관성 확보                             |
| 3    | 서브시스템 설계          | 서브시스템 명세   | 서비스스템의 기능/제약사항 명세, 시스템 기능을 독립적이고 명확하게 정의 |
| 4    | 컴포넌트 설계            | 컴포넌트 명세     | 각 기능별 컴포넌트 설계, 컴포넌트간 인터페이스 정의                     |
| 5    | 자료구조와 알고리즘 설계 | 구현              | 데이터 저장 방식, 기본 연산 방법 설계                                   |

*요구사항 명세 기반으로 아키텍쳐/데이터베이스 설계 진행*

**<span style="color: red;">협약에 의한 설계</span>**: 클래스의 조건을 명세해서 시스템간 안정성 유지를 목적으로 함

- <span style="color: red;">선행조건</span>: 컴포넌트  오퍼레이션 사용 전 "참"이 되어야 하는 조건
- <span style="color: red;">결과조건</span>: 컴포넌트 오퍼레이션 사용 후 "만족"해야 하는 조건
- <span style="color: red;">불변조건</span>: 오퍼레이션 실행되는 동안 항상 "만족"해야 하는 조건

### 소프트웨어 아키텍처

#### SW 아키텍처

시스템의 기본 구조(골격), 고수준의 설계 지침 제공, 개발 방향성 제시

**SW 아키텍처 특징(원칙)**

- 간략성: 이해/추론이 쉽도록 간결하게 유지
- 추상화: 전반 구조를 추상화
- 가시성: 포함되어야 하는 모든 요소를 명확하게 시각적 표현
- 관점 모형: 다양한 이해당사자의 관심사에 따른 여러 모형을 제시하여 접근성 높임 (ex. 4+1 뷰)
- 의사소통 수단: 이해당사자 간 의사소통 수단으로 활용

**SW 아키텍처 프레임워크 구성요소**

- 아키텍처 명세서
- 이해관계자
- 관심사
- 관점
- <span style = "color:red;">뷰: 이해관계자들의 견해를 반영하여 전체 시스템을 구성하고 표현함</span>

**4 + 1 View Model**

*4: SW 구현의 4가지 관점 / 1: 사용자 관점*

![4+1 View Model](/assets/img/2025-03-07-정보처리기사실기-part1/4-1-view.png)

- 논리뷰(Logical View): 설계자가 사용자 관점에서 시스템의 기능적 요구사항을 표현
- 구현뷰(Implementation View): 개발자가 SW 모듈 구성과 컴포넌트 다이어그램으로 구현 구조 표현
- 프로세스뷰(Process View): 시스템 통합 담당자가 프로그램 실행 시 시스템 상태, 동적 측면(동시성, 분산처리, 시스템 통합)을 표현
- 배치뷰(Deployment View): 시스템 엔지니어가 시스템의 물리적 배치, 네트워크 연결 뿐만 아니라 비기능적 요구사항(성능, 가용성, 신뢰성 등)을 표현
- 유즈케이스 뷰(Use Case View): 아키텍쳐 설계 및 검증 주도, 4개의 뷰 검증 용도

#### 소프트웨어 아키텍처 패턴

공통적인 설계 문제에 대한 일반적인 접근 방법을 제시함

**중요성**

- 재사용성: 검증된 설계 방식을 재사용하여 개발 공수 절감
- 표준화: 표준화된 방식으로 설계하여 일관성↑ 유지보수성↑
- 개발 효율성: 일반적인 문제의 검증된 해결책을 제공하여 개발속도↑
- 문서화: 아키텍처 패턴은 이미 문서화되어 있어 구조를 쉽게 이해하고 공유할 수 있음

**<span style="color:red">SW 아키텍처 패턴 종류</span>**

| 유형                                                      | 설명                                                                                     | 장점                                               | 예시                                           |
| --------------------------------------------------------- | ---------------------------------------------------------------------------------------- | -------------------------------------------------- | ---------------------------------------------- |
| 계층화 패턴                                               | 소프트웨어를 여러 계층으로 구분, 각 계층이 하위 계층의 기능을 사용하는 구조              | 계층간 독립성 유지보수 성 업그레이드               | OSI 7계층                                      |
| 클라이언트-서버 패턴                                      | 서버가 여러 클라이언트의 서비스를 제공하는 구조, 요청과 응답                             | 데이터관리,자원의 효율적인 활용                    | 중앙 집중식 데이터 관리                        |
| 마스터-슬레이브 패턴                                      | 마스터 컴포넌트가 작업을 슬레이브에 분산 시키면,슬레이브가 처리 결과를 마스터의 전달함   | 복잡한 작업에 처리 속도 향상                       | 고성능 컴퓨팅 환경, 병렬 컴퓨팅                |
| 파이프-필터 패턴                                          | 데이터 스트림 처리 시스템에서<br>- 단계별 처리: 필터<br>- 결과 전달: 파이프              | 시스테 확장성, 재사용성 향상                       | Unix 쉘 스크립트, 데이터 스트림 처리 시스템    |
| 브로커 패턴                                               | 분산시스템에서 컴포넌트간 통신(요청/처리결과)을 중재하는 브로커 컴포넌트를 사용하는 구조 | 시스템 유연성, 확장성 향상                         | ORB 미들웨어, 오버로딩                         |
| <span style="color:red">피어 투 피어 패턴</span>          | 모든 컴포넌트(피어)가 서버와 클라이언트 역할을 동시수행하는 구조                         | 중앙집중식 서버에 의존하지 않는 분산 네트워크 구조 | 파일 공유시스템                                |
| 이벤트-버스 패턴                                          | 이벤트 버스로 메시지 발생하면 리스너가 구독하는 구조                                     | 이벤트 기반 비동기 통신                            | 메시징/알림 시스템                             |
| <span style="color:red">모델-뷰-컨트롤러 패턴(MVC)</span> | 모델(데이터 처리) + 뷰(UI) + 컨트롤러(입력 처리)로 구성                                  | 컴포넌트간 독립성, 재사용성, 확장성 향상           | 웹 어플리케이션                                |
| 블랙보드 패턴                                             | 여러 컴포넌트가 공유하는 중앙정보 저장소(블랙보드)를 통한 협업구조                       | -                                                  | 복잡하고 명확한 해결 전략이 정의되지 않았을 때 |
| 인터프리터 패턴                                           | 특정 프로그래밍 언어의 해석/실행을 위한 컴포넌트 설계에 사용                             | -                                                  | -                                              |

### <span style="color:red;">UML</span>
*1문제 출제 예상*

#### UML

SW를 시각화/문서화 시, <span style="color:red;">시스템구조(정적구조)</span>와 <span style="color:red;">동작(동적구조)</span>을 표준화된 언어로 명세하는 모델링 언어

**특징**

- 가시화 언어: 시스템구조와 동작을 시각화하여 쉽게 이해
- 명세화 언어: 표준화된 언어로 요구사항/기능 명세
- 구축 언어: UML 기반으로 구현 진행됨
- 문서화 언어: 커뮤니케이션 및 산출물로 활용

#### <span style="color:red;">구성요소: 사물/관계/다이어그램</span>

**사물(Thing)**

- <span style="color:red;">구조사물</span>: 시스템의 개념적, 물리적 요소 표현 (ex. 클래스, 유스케이스, 컴포넌트 등)
- <span style="color:red;">행동사물</span>: 시공간에 따라 변화하는 요소들의 행위 표현 (ex. 상호작용, 상태머신 등)
- 그룹사물: 요소를 그룹으로 묶어서 표현 (ex. 패키지)
- 주해사물: 부가 설명, 제약조건 (ex. 주석)

**<span style="color:red;">관계(Relationship)</span>**

| 관계 유형                   | ⭤   | 관계 유형                |
| --------------------------- | --- | ------------------------ |
| 일반화 관계(Generalization) | ⭤   | 실체화 관계(Realization) |
| 연관 관계(Association)      | ⭤   | 의존 관계(Dependency)    |
| 집약 관계(Aggregation)      | ⭤   | 합성 관계(Composition)   |

- **일반화 관계(Generalization)**
	- 객체지향 개념에서 <span style="color:red;">상속 관계(Inheritance)</span>, 상위 클래스의 속성과 메서드를 하위클래스가 물려받음
	- *부모(슈퍼)클래스, 자식(서브)클래스 모두 실체화 될 수 있음*

	![일반화 관계](/assets/img/2025-03-07-정보처리기사실기-part1/generalization.png)
- **실체화 관계(Realization)**
	- <span style="color:red;">인터페이스의 추상메서드를 구현 클래스가 상속받아서 오버라이딩(재정의)</span>하는 관계
	- *인터페이스는 추상화, 구현클래스는 실체화 됨*

	![실체화 관계](/assets/img/2025-03-07-정보처리기사실기-part1/realization.png)
- **연관 관계(Association)**
	- <span style="color:red;">한 클래스가 다른 클래스의 기능을 사용</span>할 때, 두 객체가 <span style="color:red;">서로 연관</span>되어 있음을 표현

  ![연관 관계](/assets/img/2025-03-07-정보처리기사실기-part1/association.png)
- **의존 관계(Dependency)**
	- 한 클래스가 다른 클래스의 기능을 일시적으로 사용할 때 관계
	- <span style="color:red;">한 클래스가 다른 클래스를 오퍼레이션의 매개변수로 사용</span>하는 경우
	- 한 클래스의 명세가 변경되면 다른 클래스에 영향을 미침

	![의존 관계](/assets/img/2025-03-07-정보처리기사실기-part1/dependency.png)
- **집약 관계(Aggregation)**
	- <span style="color:red;">한 객체(전체 객체)가 다른 객체(부분 객체)를 소유</span>하는 'has a' 관계이지만, <span style="color:red;">객체간 독립적</span>임
	- *전체 객체가 사라져도 부분 객체는 사라지지 않음*

	![집약 관계](/assets/img/2025-03-07-정보처리기사실기-part1/aggregation.png)
- **합성 관계(Composition)**
	- <span style="color:red;">부분 객체가 전체 객체에 속하는 긴밀/필수적인 관계</span>로, <span style="color:red;">객체간 의존적</span>임
	- *전체 객체가 사라지면 부분 객체도 사라짐*

	![합성 관계](/assets/img/2025-03-07-정보처리기사실기-part1/composition.png)

**다이어그램(Diagram)**

| 구조(정적) 다이어그램                         | 설명                                                                                                        |
| --------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| 클래스 다이어그램 (Class)                     | - 클래스 및 이들 간의 관계 표현<br>- 데이터 구조와 클래스 간 상속/연관/의존성 표현                          |
| 객체 다이어그램 (Object)                      | - 객체 및 이들 간의 관계를 특정 시점에서 시각화 표현                                                        |
| 컴포넌트 다이어그램 (Component)               | - 논리적 구성요소(컴포넌트: 모듈의 묶음 단위) 및 이들 간 의존성 표현<br>- 컴포넌트, 인터페이스, 의존성 표현 |
| 배치 다이어그램 (Deployment)                  | - 시스템 물리적 배치, 구성요소 간 관계 표현<br>- 하드웨어, 네트워크, SW 구성요소 표현                       |
| 복합체 구조 다이어그램 (Complex Constructure) | - 복합구조, 클래스, 컴포넌트의 내부구조 및 상호작용 표현                                                    |
| 패키지 다이어그램 (Package)                   | - 패키지, 클래스 간 그룹화 및 관계 시각화                                                                   |

| 행위(동적) 다이어그램                  | 설명                                                                                                                                                                          | 예시                                                                                                |
| -------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| 유즈케이스 다이어그램 (Use Case)       | - 시스템의 기능과 사용자 간 상호작용 표현<br>- 요구사항 문서화에 활용<br>- 구성요소: 시스템, 액터, 유즈케이스, 관계                                                           | ![유즈케이스 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/usecase-diagram.png)<br><br> |
| 순차 다이어그램 (Sequence)             | - 시간 순서에 따라 객체 간 상호작용(by 메시지) 표현<br>- 구성요소: 활성객체, 메시지, 생명선, 활성 박스<br>- 메시지 유형: 동기 메시지, 비동기 메시지, 반환 메시지, 자체 메시지 | ![순차 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/sequence-diagram.png)<br><br>      |
| 커뮤니케이션 다이어그램(Communication) | 객체 간 상호작용과 통신 표현                                                                                                                                                  | ![커뮤니케이션 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/communication-diagram.png) |
| 상태 다이어그램 (State)                | 객체 생명주기동안 외/내부 이벤트에 의한 상태 변화 표현                                                                                                                        | ![상태 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/state-diagram.png)<br><br>         |
| 활동 다이어그램 (Activity)             | - 시스템의 프로세스, 워크플로우 표현<br>- 비즈니스 프로세스 모델링                                                                                                            | ![활동 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/activity-diagram.png)              |
| 상호작용 다이어그램(Interaction)       | - 시스템의 상호작용을 워크플로우로 표현<br>- 활동 다이어그램 + 순차 다이어그램                                                                                                | ![상호작용 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/interaction-diagram.png)       |
| 타이밍 다이어그램(Timing)              | - 객체 행동/시간에 따른 상태 변화, 상호작용 표현<br>- 시간에 따른 타이밍에 초점                                                                                               | ![타이밍 다이어그램](/assets/img/2025-03-07-정보처리기사실기-part1/timing-diagram.png)              |

#### 주요 다이어그램

**클래스 다이어그램**

| 접근제한자 | 표기법 | 사용 범위                      |
| ---------- | ------ | ------------------------------ |
| public     | +      | 어디서든 접근 가능             |
| protected  | \#     | 상속, 동일 패키지 내 접근 가능 |
| public     | -      | 동일 클래스 내 접근 가능       |

**유즈케이스 다이어그램**

| 구성요소   | 설명                                        |
| ---------- | ------------------------------------------- |
| 시스템     | 개발 대상 시스템                            |
| 액터       | 시스템과 상호작용하는 사람 또는 외부 시스템 |
| 유즈케이스 | 사용자 입장에서 시스템의 주요 기능          |
| 관계       | 액터와 유즈케이스 간 관계 표현              |

- 연관 관계(Association): 유즈케이스와 액터 간 관계

  ![연관 관계](/assets/img/2025-03-07-정보처리기사실기-part1/usecase-diagram-association.png)
- 포함 관계(Include): 특정 유즈케이스 수행에 반드시 포함되어 실행되는 다른 유즈케이스

  ![포함 관계](/assets/img/2025-03-07-정보처리기사실기-part1/usecase-diagram-include.png)
- 확장 관계(Extend): 유즈케이스 수행 중 조건에 따라 확장 기능이 실행되는 경우

  ![확장 관계](/assets/img/2025-03-07-정보처리기사실기-part1/usecase-diagram-extend.png)
- 일반화 관계(Generalization): 유사 유즈케이스, 액터를 추상화하여 상위 개념으로 묶어 표현

  ![일반화 관계](/assets/img/2025-03-07-정보처리기사실기-part1/usecase-diagram-generalization.png)

**시퀀스(순차) 다이어그램**

![시퀀스 다이어그램 메시지](/assets/img/2025-03-07-정보처리기사실기-part1/sequence-diagram-message.png)

## Ch4.  화면 설계

### UI 설계

#### UI(User Interface) 개념

**UI**

User Interface, 기기와 사용자 간 상호작용이 가능한 매개체

**UX**

User Experience, 사용자가 UI를 통해 경험한 모든 요소

**<span style="color:red;">UI 유형</span>**

| 유형                                   | 설명                                                       |
| -------------------------------------- | ---------------------------------------------------------- |
| CLI(Command Line Interface)            | 명령어를 입력해서 조작하는 방식                            |
| GUI(Graphic User Interface)            | 그래픽/텍스트 기반으로 사용자 입력을 직관적으로 받는 방식  |
| NUI(Natural User Interface)            | 사용자의 자연스러운 움직임을 인식하여 정보를 제공하는 방식 |
| OUI(Organic User Interface)            | 현실의 모든 요소를 입/출력 장치로 사용하는 방식            |
| VUI(Voice User Interface)              | 사용자의 음성인식 기반 상호작용 방식                       |
| ARUI(Augmented Reality User Interface) | 증강 현실 기술을 활용하는 상호작용 방식                    |

#### UI 설계

**UI 요구사항 구분**
- 기능적 요구사항: 시스템이 제공해야 하는 기능 (입/출력, 데이터, 연산 등)
- 비기능적 요구사항: 시스템 품질에 대한 요구사항 (사용성, 효울성, 신뢰성, 유지보수성, 재사용성 등)

**설계 절차**

UI 개발 목표/범위 수립 → 전략 수집 → 사용자 요구사항 분석 → UI 상세 설계 → 구현 → 테스트

**<span style="color:red;">UI 설계 원칙</span>**
- 직관성: 누구나 쉽게 이해할 수 있어야 함
- 유효성: 사용자의 목적을 정확하게 달성해야 함
- 학습성: 누구나 쉽게 배울 수 있어야 함
- 유연성: 사용자 요구사항을 최대한 수용하고, 오류를 최소화 해야 함

**UI 설계 도구**
- 와이어프레임: 간략하게 기본 구조, 레이아웃을 표현하는 초기 설계 도구
- 스토리보드: 시나리오 흐름을 시각적으로 표현, 인터렉션 세부화
- 프로토타입: 실제 서비스와 유사하게 동작하는 모델
- 목업: 와이어프레임보다 구체적으로 실제 화면과 유사한 정적 디자인
- 유스케이스: 사용자 관점에서 목표달성을 위한 동작 사니라오 기술

#### 감성공학
- 인간 감정을 물리적 설계요소로 번역/구현하는 기술
- 단계: 요소화 → 형상화 → 구현 → 생산

**감성 종류 및 감성공학 접근 방법**

| 감성공학 접근 방법 | 인간 감성 종류 | 설명                                           |
| ------------------ | -------------- | ---------------------------------------------- |
| 1류 접근 방법      | 감각적 감성    | 제품에 대한 이미지 분석해서 디자인 요소와 연결 |
| 1류 접근 방법      | 기능적 감성    | 제품 성능 및 사용 편의성을 디자인 요소와 연결  |
| 2류 접근 방법      | 문화적 감성    | 사회/문화로 형성된 감성을 제품에 적용          |
| 3류 접근 방법      | -              | 감성을 정량화하여 제품설계에 적용              |

### UI 구현

레이아웃: 웹페이지 구성요소를 효과적으로 배치하는 작업

#### HTML5

웹 문서의 <span style="color:red">기본 구조 담당</span> + 멀티미디어 기능 포함

| 특징          | 설명                                         |
| ------------- | -------------------------------------------- |
| 멀티미디어    | 플러그인 없이 동영상, 음악 재생 가능         |
| 그래픽        | SVG, CANVAS로 2차원 그래픽 표현              |
| 통신          | 웹 소켓으로 실시간 통신                      |
| 지리적 위치   | GPS 활용한 위치 확인 및 장치 접근            |
| 오프라인 작업 | 로컬 스토리지, 오프라인 캐시로 오프라인 작업 |

**시멘틱 요소**

![HTML 시멘틱 요소 형태](/assets/img/2025-03-07-정보처리기사실기-part1/html-semantic-elements.png)

| 시멘틱 TAG | 포함 요소                        |
| ---------- | -------------------------------- |
| \<header>  | 제목, 네비게이션, 검색 기능 포함 |
| \<nav>     | 메인 메뉴, 목차                  |
| \<section> | 유사한 맥락 요소를 그룹화        |
| \<article> | 본문 주요 내용                   |
| \<aside>   | 본문 외 사이드 컨텐츠 영역       |
| \<footer>  | 작성자, 회사 정보 등             |

**Input 요소**

![Input 요소 예시](/assets/img/2025-03-07-정보처리기사실기-part1/html-input-example.png)

| Input 요소               | 설명                                                                   |
| ------------------------ | ---------------------------------------------------------------------- |
| 텍스트 입력              | - text: 텍스트 한 줄 입력 가능<br>- textarea: 텍스트 여러 줄 입력 가능 |
| 비밀번호 입력 (password) | 입력 문자를 별, 작은 원으로 표시                                       |
| 라디오 버튼 (radio)      | 택 1 옵션                                                              |
| 체크버튼 (check)         | 다중 선택 옵션                                                         |
| 파일 선택 (file)         | 사용자 로컬에서 파일 선택/업로드                                       |
| 선택 입력 (select)       | 드롭다운                                                               |
| 버튼 (button)            | 클릭 했을 때 동작 수행                                                 |
| 전송 (submit)            | 입력 받은 데이터를 서버로 전송                                         |
| 필드셋 (fieldset)        | 관련 데이터를 하나로 묶음                                              |

#### CSS

웹 문서의 <span style="color:red">디자인적 요소</span> 담당

| 특징                                     | 설명                                                                |
| ---------------------------------------- | ------------------------------------------------------------------- |
| 디자인 분리                              | 구조(html)과 디자인(css)를 독립적으로 유지 관리 가능                |
| 재사용성                                 | 잘 정의하면 여러 웹 페이지에 재사용 가능                            |
| 동적 디자인                              | javascript와 연계로 동적 컨텐츠 표현 가능                           |
| <span style="color:red">반응형 웹</span> | 다양한 기기에 맞춰 컨텐츠 크기 자동 변경<br>(단점: 공수↑ 실행속도↓) |

#### Javascript

- 클라이언트 측 웹페이지의 <span style="color:red">동적 동작</span> 담당
- 라이브러리 종류: React / Vue.js / AngularJS
- <span style="color:red">AJAX(Asynchronous Javascript and XML)</span>
	- 비동기 통신 웹 어플리케이션 제작 기법
	- 페이지 전체를 새로고침하지 않고도 부분 업데이트가 가능함
	- 실행 속도 향상시킴

#### UI 관련 용어

| 용어                                     | 설명                                                                      |
| ---------------------------------------- | ------------------------------------------------------------------------- |
| 웹 표준                                  | - 웹에서 사용하는 공식 표준 및 기술 규격<br>- 호환성↑ 접근성↑ 효율성↑     |
| 웹 호환성                                | 다양한 HW/SW 환경에서 웹 서비스에 대한 일관된 사용자 경험을 제공하는 능력 |
| 웹 접근성                                | 장애인/비장애인 모두 동일하게 웹 서비스를 접근, 이용할 수 있는 방식       |
| <span style="color:red">반응형 웹</span> | 다양한 기기에 맞춰 컨텐츠 크기 자동 변경 (단점: 공수↑ 실행속도↓)          |
| 인포그래픽                               | 정보(information) + 그래픽(graphic), 복잡한 정보를 시각화하는 방식        |
| 내비게이션                               | 하이퍼링크로 정보를 탐색하고 접근하는 과정                                |
| 아코디언                                 | 공간이 확장/축소될 수 있는 패널 형식 컨텐츠                               |
| 플레이스 홀더                            | 입력 필드에 예시, 가이드라인 용 텍스트                                    |
| 썸네일                                   | 큰 이미지를 크기/용량 축소시킨 작은 버전 이미지                           |
| 레이블                                   | 입력 폼의 필드 구분 목적 텍스트                                           |
| 대체텍스트                               | 이미지, 그래픽 컨텐츠 대신 제공되는 텍스트                                |

## Ch5. 서버 프로그램 구현
### 프로그래밍 기초 개념
#### 알고리즘 표현 방법

**자연어**
- 일상적으로 사용하는 언어
- 장점: 쉽게 이해 가능, 단점: 모호함

**의사코드(Pseudo Code)**
- 프로그래밍 언어의 형식을 모방한 코드 (실제 프로그래밍 언어 아님)
- 알고리즘의 논리적 구조를 명확하게 표현 가능

**순서도(Flow Chart)**
- 기호, 도형으로 과정과 절차를 시각적으로 표현

**나씨 슈나이더만 차트(Nassi-Schneiderman Chart)**
- 순차/선택/반복 구조를 상자도표로 도식화

![나씨 슈나이더만 차트 형식](/assets/img/2025-03-07-정보처리기사실기-part1/nassi-schneiderman-chart.png)

**UML(Unified Modeling Language)**
- SW 구조/설계를 시각적으로 표현하는데 사용하는 표준화된 모델링 언어
- 다양한 유형의 다이어그램 있음

#### 변수 표기법

| 표기법          | 특징/용도                                                                   | 예시         |
| --------------- | --------------------------------------------------------------------------- | ------------ |
| 카멜 표기법     | - 첫 단어 제외, 나머지 단어 첫 글자 대문자<br>- 매서드명, 변수명            | flowChart    |
| 파스칼 표기법   | - 모든 단어 첫 글자 대문자<br>- 클래스명, 네임스페이스                      | FlowChart    |
| 스네이크 표기법 | - 소문자 표기, 단어 사이 언더바(_)<br>- C, Python에서 변수명, 함수명        | flow_chart   |
| 헝가리안 표기법 | - 자료형 및 특성을 접두사로 붙임                                            | strFlowChart |
| 케밥 표기법     | - 소문자 표기, 단어 사이 대시(-)<br>- 웹 개발에서 url, 파일명, css 클래스명 | flow-chart   |

#### 프로그래밍 언어 유형 분류

**언어 수준에 따른 분류**

| 분류     | 설명                                                                                                                                   |
| --------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| 저급 언어 | - 컴퓨터가 직접 이해할 수 있는 언어<br>- 기계어, 어셈블리어<br>- 장점: 실행 속도 빠름<br>- 단점: 기계마다 달라 호환성, 유지관리 어려움 |
| 고급 언어 | - 인간이 이해할 수 있는 소스 코드 언어<br>- 실행 시 저급언어로 변환하는 과정 필요                                                      |

**빌드 방식에 따른 분류**

| 분류            | 설명                                                                                                                                                     |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 컴파일 언어      | - PC가 이해가능한 목적코드로 실행 시 최초 1번 변환<br>- C, C++ ...                                                                                       |
| 인터프리터 언어  | - 소스 코드를 한 줄 씩 실행하면서 컴퓨터가 이해가능한 언어로 변환<br>- Python, BASIC ...                                                                 |
| 바이트 코드 언어 | - 소스 코드를 컴파일 하면 가상 머신이 이해할 수 있는 바이트 코드로 변환<br>- 이후 가상 머신이 기계어로 변환<br>- JAVA (JAVA의 가상 머신: JVM), Scala ... |
| 어셈블리 언어    | - 기계어와 1:1 대응관계로 작성<br>- 어셈블러를 통해 기계어로 변환<br>- 하드웨어 제어, 시스템 레벨 프로그래밍 ...                                         |

#### 절차적 프로그래밍 언어

**특징**
- <span style="color:red">하항식</span>, 주로 DFD로 설계
- 문법에 따라 순서대로 기술, 순차적으로 처리
- Procedure(루틴, 서브루틴, 메서드, 함수) 사용
- 종류: C, COBOL, FORTRAN, BASIC

**장점/단점**

| 장점                                               | 단점                                                             |
| --------------------------------------------------- | ---------------------------------------------------------------- |
| - 함수를 통한 재사용성↑<br>- 컴퓨터 처리구조와 유사 | - 복잡할 수록 분석/이해 어려움<br>- 코드 수정 및 유지보수 어려움 |

#### 객체지향 프로그래밍 언어

**특징**
- <span style="color:red">상향식</span>, 주로 UML로 설계
- SW 구조를 객체로 구성하고, 객체 간의 상호작용으로 SW 동작시킴
- 종류: JAVA, C++, Python, Objective-C, 시뮬라67, 스몰토크

**장점/단점**

| 장점                                                                           | 단점                                                                                |
| ------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| - 코드 재사용성↑<br>- 현실 객체 개념과 유사<br>- 모듈화된 코드로 수정/관리 용이 | - 초기 설계, 구현에 공수↑<br>- 객체간 메시지 전달로 실행속도↓<br>- 개념 설계 복잡함 |

### 개발 환경 구축
#### 서버 환경 구축

**웹 서버(Web Server)**
- 클라이언트에 정적 파일(HTML, CSS, Javascript, 이미지 등)을 제공하는 서버
- Apache Web Server, Nginx, IIS, GWS ...

**웹 어플리케이션 서버(WAS, Web Application Server)**
- 클라이언트에 동적인 웹 서비스를 제공하는 서버
- 정적 내용에 DB 조회 또는 로직 처리를 결합시켜서 보여줌
- Tomcat, WebLogic, JEUS ...

**데이터베이스 서버(DBMS)**
- 데이터 저장, 관리를 위한 서버
- Oracle, MySQL, NS-SQL ...

**파일 서버(File Server)**
- 사용자가 첨부한 파일을 저장, 공유할 때 사용되는 서버

**로드밸런서(Load Balancer, L4 스위치)**
- 서버 부하 분산 목적으로 여러 서버 사이에서 네트워크 요청을 효율적으로 분배하는 장치

**CDN(Content Delivery Network)**
- 이미지, 비디오 등 대용량 컨텐츠를 여러 서버에 분산시키고, 사용자가 조회할 때 사용자 기준으로 물리적으로 가까운 서버/네트워크를 이용하는 방식 (컨텐츠 조회 속도↑)

![시스템 아키텍처 구성 예시](/assets/img/2025-03-07-정보처리기사실기-part1/system-architecture.png)

> 시스템 아키텍처 고려사항: 확장성, 성능, 응답시간, 접근성, 일관성, 보안

#### 시스템 소프트웨어 환경

**운영체제(OS, Operating System)**
- PC 하드웨어 운영을 관리하는 소프트웨어, 인터페이스 역할 및 시스템 자원 관리
- Windows, Linux, UNIX ...

**JVM(Java Virtual Machine)**
- 자바 관련 프로그램을 실행하기 위한 가상 머신 환경 제공
- 동일한 Java 소스코드 1벌로 여러 다양한 운영체제에서 호환가능하게 실행시켜 줌

**WAS**

**DBMS**

#### 개발 도구(소프트웨어)
- 요구사항 관리 도구
- 설계/모델링 도구
- <span style="color:red;">구현 도구(IDE, Integrated Development Environment)</span>
- 테스트 도구(ex. JUnit, CppUnit)
- <span style="color:red;">형상 관리 도구</span>
- 협업 도구
- 배포 도구

#### IDE

- SW개발에 필요한 다양한 기능을 하나의 프로그램 내에서 통합 제공
- 기능: 텍스트 에디터, 컴파일러, 디버거, 배포, 플러그인 등
- 종류: Eclipse, Visual Studio, IntelliJ, Xcode ...

#### 형상 관리 도구

**형상 관리**
SW 개발 과정에서 발생하는 모든 변경 사항을 체계적으로 추적/관리/기록하여 통제/관리 하는 방법

**변경사항 관리 수준 구분**

| 구분     | 설명                                                                               |
| --------- | ---------------------------------------------------------------------------------- |
| 변경 관리 | 소스 코드 변경 사항 관리, 문서 변경 이력 및 복원 기능 제공                         |
| 버전 관리 | 체크인/체크아웃, 릴리즈, 퍼블리싱 등 SW 변경 관리 기능 제공                        |
| 형성 관리 | - 변경 관리 + 버전 관리<br>- 통합 관리 시스템: 프로젝트 진행 상황, 빌드, 릴리즈 등 |

**형상 관리 절차**

| 관리 순서                               | 설명                                                                                                 |
| ---------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| 형상 식별                                | 번호, 태그로 관리 항목 구분                                                                          |
| <span style="color:red">형상 통제</span> | <span style="color:red">변경 요청을 검토하고 승인하여 현재의 기준선(baseline)에 반영하는 활동</span> |
| 형상 감사                                | 계획에 따라 변경 되었는지 검토                                                                       |
| 형상 기록/보고                           | 변경 사항, 처리과정을 기록하고 이해관계자에게 보고함                                                 |

#### 버전 관리 도구

**공유 폴더 방식**
파일을 공유 폴더에 저장하고, 담당자가 에러 체크 및 정상 작동 여부를 확인
- RCS
- SCCS

**클라이언트/서버 방식**
중앙서버에 버전 관리 시스템 운영, 개발자들은 이 시스템과 연동해서 작업
- CVS
	- 중앙 저장소에 파일 저장, 인가된 사용자만 파일 접근 가능
	- 속도 느림
- <span style="color:red">SVN</span>
	- CVS 단점 보완
	- 최초 1회 파일 원본을 저장한 후 변경 사항만 기록함

**분산 저장소 방식**
중앙저장소/로컬저장소 별도 존재, 로컬에서 독립적으로 작업 후 중앙 저장소에 변경사항 반영
- <span style="color:red">Git</span>
	- 리누스 토발즈 개발
	- 로컬에서 빠르게 작업할 수 있고 다양한 브랜치 생성 및 관리 가능
	- 분산 환경에 최적화되어 원격 저장소에 장애가 있어도 로컬 버전에서 버전 관리 가능

| 용어       | 설명                                 |
| ---------- | ------------------------------------ |
| Repository | 저장소                               |
| Checkout   | 저장소에서 로컬로 프로젝트 복사      |
| Commit     | 로컬에서 변경된 내용을 저장소에 반영 |
| Update     | 저장소에 있는 내용을 로컬에 반영     |
| Add        | 로컬에서 추가된 파일을 저장소에 등록 |
| Trunk      | 루트 프로젝트                        |
| Branch     | 루트 프로젝트에서 파생된 프로젝트    |
| Merge      | Branch 작업을 Trunk에 합침           |
| Diff       | 파일 비교                            |

#### 빌드(배포) 도구

소스코드 파일을 실행가능한 SW로 변환하는 과정
<span style="color:red">빌드, 테스트, 배포</span>

**빌드 자동화 도구 종류**
- Make
	- Unix 계열 운영체제에서 사용하는 빌드 도구
- Ant
	- Java 기반 빌드 도구
	- xml 기반 빌드 스크립트 사용: 유연성↑ 재사용성↓
- Maven
	- 의존성 관리에 강점이 있는 Java 기반 빌드 도구
	- pom.xml 파일로 라이브러리간 의존성을 자동으로 관리하거나 다운로드함
- Jenkins
	- Java 기반 오픈소스 지속적 통합(CI, Continuous Integration) 서비스 도구
	- 빌드, 테스트, 배포 과정 자동화
	- SVN, Git 등 형상 관리 도구와 자동 연동 가능
	- 분산 빌드 환경 지원
- Gradle
	- 오픈 소스 빌드 자동화 도구
	- 안드로이드 앱 개발 뿐만 아니라 Java, C/C++, Python 등 다양한 언어 빌드 지원

### 모듈 구현

#### 단위 모듈 구현
- 단위 모듈: sw를 기능 단위로 분해하여 개별 구현하는 기법
- <span style="color:red">좋은 모듈화란? : 독립적이고 활용성 높음</span>
	- 응집도↑ 결합도↓
	- Fan-in 최대화, Fan-out 최소화
	- 단순성 높게 설계 (입력 1개, 출력 1개)

**단위 모듈 설계 원리**
- 단계적 분해: 점진적으로 상세화
- 추상화: 복잡한 문제를 간단/일반화
- 독립성: 높은 응집도, 낮은 결합도 유지
- 정보 은닉: 모듈 내부 데이터 및 로직 보호
- 분할과 정복: 큰 문제를 작은 부분으로 나눠서 해결

#### 결합도(Coupling)

모듈 간 관련성, 의존성 정도

| 유형                                                 | 설명                                         |
| ---------------------------------------------------- | -------------------------------------------- |
| <span style="color:red">자료(Data) 결합도</span>     | 값만 전달                                    |
| <span style="color:red">스탬프(Stamp) 결합도</span>  | 주소값(배열, 오브젝트, 스트럭처) 전달        |
| <span style="color:red">제어(Control) 결합도</span>  | 처리 대상값과 제어요소(if) 전달              |
| <span style="color:red">외부(External) 결합도</span> | 한 모듈에서 선언된 데이터를 외부 모듈이 참조 |
| <span style="color:red">공통(Common) 결합도</span>   | 모듈 내에서 모듈 밖의 전역 변수를 참조, 갱신 |
| <span style="color:red">내용(Content) 결합도</span>  | 모듈 내에서 다른 모듈의 변수, 기능 사용      |

> 암기 방법: 테스형 쟤 왜저래 공유랑 내가 닮았대

#### 응집도(Cohension)

모듈 내부에서 구성요소 간 밀접한 관계 정도

| 유형                                                        | 설명                                                     |
| ----------------------------------------------------------- | -------------------------------------------------------- |
| <span style="color:red">우연적(Coincidental) 응집도</span>  | 서로 연관 없음                                           |
| <span style="color:red">논리적(Logical) 응집도</span>       | 유사 성격/특정 분류에 해당하는 처리요소 모음             |
| <span style="color:red">시간적(Temporal) 응집도</span>      | 특정 시간에 처리하는 활동 모음                           |
| <span style="color:red">절차적(Procedual) 응집도</span>     | 기능이 순차적으로 처리                                   |
| <span style="color:red">통신적(Communication) 응집도</span> | 동일한 입/출력을 사용하는 다양한 기능 모음               |
| <span style="color:red">순차적(Sequential) 응집도</span>    | 모듈 내 한 활동의 출력값이 다른 활동의 입력값으로 사용됨 |
| <span style="color:red">기능적(Functional) 응집도</span>    | 모듈 내 모든 기능이 단일 목적을 위해 수행됨              |

> 암기 방법: 우리 놀던 시절에 통통한 순대가 기가 막혔어

#### Fan-in, Fan-out

**Fan-in**
- 특정 모듈을 호출/사용하는 상위 모듈 수
- 높을 수록 좋은 모듈화

**Fan-out**
- 특정 모듈이 호출/사용하는 하위 모듈 수
- 낮을 수록 좋은 모듈화

<span style="color:red">Fan-in, Fan-out 계산방법</span> 숙지할 것