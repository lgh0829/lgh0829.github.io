---
title: 정보처리기사 실기) PART1. 소프트웨어 구축
description: 소프트웨어 구축 이론 정리
author: GH Lee
date: 2025-03-07 00:00:00 +0900
categories: [License]
tags: [License][Note]
pin: false
math: false
mermaid: false
---
## Ch1. 소프트웨어 공학 개념
### 소프트웨어 공학
#### 정의
품질 높은 소프트웨어를 효율적으로 개발하기 위한 방법, 도구, 이론
#### 3R
역공학(Reverse Engineering)
- 이미 개발된 시스템의 소스코드에 기반하여 문서(설계명세서, 요구분석서)를 역산출하는 방식
재공학(Re-Engineering)
- 기존 소프트웨어를 개선, 유지보수하여 생산성 위기를 해결하는 방식
- 과정: 분석 - 재구성 - 역공학 - 이관
	- 분석: 기존 소프트웨어를 검토하여 재공학 대상을 선정
	- 재구성: 소프트웨어 구조개선 목적으로 코드를 재구성하되, 외적 기능은 변경하지 않음
	- 역공학: 소프트웨어 소스코드를 분석해서 설계 수준 도출
	- 이관: 다른 운영체제, 프레임워크에서 사용할 수 있도록 소프트웨어 변환 작업
재사용(Reuse)
- 기존 소프트웨어의 전체 또는 일부를 다시 사용하는 방식
- 범위
	- 함수, 객체 재사용: 클래스나 함수 단위로 재사용
	- 컴포넌트 재사용: 독립적인 소프트웨어 컴포넌트를 재사용
	- 애플리케이션 재사용: 애플리케이션 전체 또는 일부를 재사용
- 재사용 방법
	- 합성중심(Composition Based, 블록구성): 블록처럼 소프트웨어 부품을 조합해서 전체를 완성
	- 생성중심(Generation Based, 패턴구성): 추상화된 형태의 명세를 구체화하여 특정 패턴을 적용하는 방식으로 프로그램 생성
#### 개발단계
계획 - 요구사항분석 - 설계 - 구현 - 테스트 - 유지보수
- 계획: 개발 내용을 정의하고 비용/기간을 예측해서 프로젝트를 발주하거나 폐기함
- 요구사항분석: 고객의 머리속에 있는 생각을 끄집어내서 구체화
- 구현: 개발 진행(코딩, 디버깅, 단위테스트)
- 테스트: 요구사항대로 구현됐는지 확인
- 유지보수: 프로그램 운영 및 기능 개선
### 소프트웨어 개발 방법론
#### 구조적 방법론
정의
- 절차지향적인 개발 방법론
- 하향식: 사전에 정의된 구조로 코드를 작성하고 순차적으로 실행 (ex. C, Fortran, Cobol)
구성요소
- 데이터흐름도 (DFD, Data Flow Diagram): 전체적인 데이터 흐름 표현
- 데이터사전 (DD, Data Dictionary): 시스템에서 사용되는 데이터 세부사항을 문서화
- 상태전이도 (STD, State Transition Diagram): 시스템이 동작에 의한 상태의 변화를 모델링
- 소단위명세서(Minispec): 모듈의 기능과 로직을 상세히 설명
- +) ERD(Entity Relationship Diagram): DB 구조를 설명
#### 정보공학 방법론
정의
- 기업 내부 데이터 중심 접근 방식으로 sw개발을 넘어 기업경영전략에 초점
- 계획, 분석, 설계, 구축에 정형화된 기법을 적용
#### 객체지향 방법론
정의
- 모든 유무형을 객체화하는 개발 방법론
- 상향식: 객체와 클래스간의 관계를 식별하고 이를 설계 모델로 변환 (ex. JAVA, Javascript, Python)
- 구성요소: 객체(인스턴스), 클래스, 속성, 메서드, 메시지
	- 클래스: 틀
	- 속성
	- 메서드: 연산
	- 객체(인스턴스): 클래스를 통해 실체화된 것
	- 메시지: 객체간 소통 수단
	![[image-20250207164548989.png]]
특징
- 정보은닉: 내부구조를 외부로부터 숨겨서 안정성 높임
- 캡슐화: 의사소통을 위해 특정 인터페이스를 제공해서 외부로부터 직접 접근을 막음
- 상속: 재사용과 확장성을 위해 기존 클래스의 속성을 받아서 새로운 클래스를 작성하는 기법 (부모 클래스로부터 자식 클래스가 속성을 물려받는 것)
- 추상화: 공통된 성질을 모아서 생산, 유지보수 효율성 증가
- 다형성: 하나의 인터페이스로 다양한 형태의 구현을 가지는 방식
	- 오버로딩: 동일한 메서드에 입력하는 인자 개수, 타입에 따라 서로 다른 결과값을 가지는 방식
	- 오버라이딩: 상속 받은 메서드를 재정의하는 방식
#### CBD(Component Based Developement) 방법론
정의
- 재사용가능한 컴포넌트를 개발하거나 상용 컴포넌트를 조합해서 어플리케이션 개발
- 확장성이 좋아 새로운 기능 추가에 용이
#### 애자일(Agile) 방법론
정의
- 변화에 빠르고 유연하게 대응하는 개발방식
- 소프트웨어 개발의 민첩성과 효율성을 강조
종류
- XP(Extream Programing): 반복적이고 점진적인 개발과 고객의 참여를 반복하여 안정성을 확보하고 개발효율성을 높임
- 스크럼(SCRUM): 유연하고 생산적인 프로젝트 관리 방식을 적용해서 효율적인 협업 지원
- FDD(Feature-Driven Development): 기능 중심 반복적 개발
- Crystal 개발 방식: 프로젝트 크기와 중요도에 따라 최적의 개발방식을 선택
### 소프트웨어 개발 모델
#### 폭포수 모델
- 선형 순차적으로 계획 → 분석 → 설계 → 구현 → 테스트 → 운영 순으로 진행하는 전통적인 개발 모형
- 안정성이 매우 높으며 이전 단계로 돌아가기 어려움
#### 프로토타이핑 모델
- 고객의 요구사항으로 ==시제품==을 만들어 결과를 예측하는 개발 모형
#### 나선형(Spiral) 모델
- 폭포수 모델 + 프로토타이핑 모델
- "계획 수립 → ==위험 분석== → 프로토타이핑 개발 → 고객평가 피드백" 절차를 점진적으로 진행하는 개발 모형
#### RAD(Rapid Application Development) 모델
- CASE 도구를 활용해서 짧은 개발주기내에 개발
- 상위 CASE 도구: 분석, 설계
- 하위 CASE 도구: 개발, 테스트, 문서화
#### V 모델
개발절차에 따라 테스트/검증 절차를 강조한 모델
테스트 단계: 단위테스트 → 통합테스트 → 시스템테스트 → 인수테스트 
![[image-20250207212111213.png]]
#### 4세대 기법(4th Generation Techniques)
요구사항 명세서 기반으로 코드를 자동 생성하는 기법
### Agile 방법론
#### 개념
짧은 주기 동안 반복 작업을 통해 신속하고 지속적으로 작동가능한 소프트웨어를 개발하는 방식
작은 구성요소를 빠르게 제공하여 변화에 민감하게 대응가능
#### 종류1: XP(Extream Programming)
개발문서보다 소스코드에 중점
고객의 요구사항에 유연하게 대응하기 위해 고객 참여와 짧은 주기 개발 과정을 반복 진행 
5가지 핵심가치: ==용기, 단순성, 의사소통, 피드백, 중점==
#### 종류2: SCRUM
기능개발, 개선에 우선순위 부여해서 개발 집중도 높임
짧은 개발 주기마다 결과물 제공
용어
- 제품백로그: 제품 단위 요구기능 목록
- 스프린트: 반복적이고 짧은 개발주기 단위
- 스프린트 계획회의: 스프린트 목표 및 스프린트 백로그 목표 계획 회의
- 스프린트 백로그: 스프린트 목표를 위한 작업 목록
- 스크럼 마스터: 스크럼 프로세스 및 활용을 보장하는 프로젝트 관리자
#### 기타 종류
- Crystal
- FDD(Feature-Driven Development)
- ASD(Adaptive Software Development): 합동 애플리케이션 개발에서 혼란을 규정하고, 혼란에 적응할 수 있는 방법론
- Lean: 낭비요소를 제거하고 품질을 향상시키는 방법론

## Ch2. 프로젝트 계획 및 분석
### 프로젝트 계획
#### 프로젝트 관리
개념
- 한정된 기간, 예산, 자원을 활용하여 사용자에게 만족스러운 제품/서비스를 개발하는 기술·관리적 활동
- 납기 준수, 예산 준수, 품질 준수로 고품질 제품을 개발하고 고객 만족 및 개발 절차 준수 목표
==핵심 관리 대상(3P)==
- 사람, People: 프로젝트 팀원 + 이해관계자의 협력
- 문제, Problem: 목표달성을 위해 해결해야 할 과제의 분석 및 설계
- 프로세스, Process: 프로젝트의 체계적인 진행 관리
PMBOK(Project Management Body of Knowledge)
- 프로젝트 관리 프로세스와 지식 체계
- 단계: 프로젝트 착수 → 프로젝트 계획 → 프로젝트 실행 → 프로젝트 통제 → 프로젝트 종료
#### ==개발 비용 산정==
하향식 산정 기법: 유사 경험을 토대로 비용 산정
- 전문가 판단기법: 전문가에게 비용 산정 의뢰
- ==델파이 기법==: 회의로 여러 전문가 의견을 종합하여 비용 산정
상향식 산정 기법: 세부 작업 단위별로 비용 산정 후 합산
- ==원시 코드 라인 수(LoC)==: (낙관치 + (4 * 중간치) + 비관치) / 6
- 개발 단계별 노력 기법: LoC 기법 확장해서 모든 개발 단계의 비용 합산
수학적 산정 기법
- ==COCOMO==: LoC 기반으로 규모예측 후 sw 유형 별 비용 산정 공식 적용
	- 조직형: 5만 라인 이하, 업무용 sw
	- 반분리형: 30만 라인 이하, 운영체제 또는 DBMS
	- 내장형: 30만 라인 이상, 대규모 복잡 sw
- ==Putnam==: Rayleigh-Norden 곡선(시간에 따른 노력 분포 표현)으로 노력 예측하는 모델
	- SLIM: Rayleigh-Norden 곡선과 Putnam 예측 모델 기반으로 한 자동화 추정 도구
- 기능 점수 기법, FP: 기능 개수 기준으로 규모 측정
	- 기능 분류
	```
	기능분류
	├── 데이터 기능
	│	├── 내부 논리 파일 (ILF)
	│	└── 외부 연계 파일 (EIF)
	└── 트랜젝션 기능
		├── 외부 입력 (EI)
		├── 외부 출력 (EO)
		└── 외부 조회 (EQ)
	```
	- 산정 요소
		- 자료 입력: 입력되는 데이터의 양식 및 복잡도
		- 자료 출력: 출력 보고서의 양식 및 복잡도
		- 명령어: 요청하는 질의 종류 및 복잡도
		- 데이터 파일: 관리하는 데이터 파일의 복잡도 및 관련성
		- 외부 인터페이스: 외부 루틴과 인터페이스 평가
#### 개발 일정 산정
일정계획 작업 순서(형식): 작업 분해(WBS) → 작업 순서/의존성 정의(PERT/CPM 네트워크 차트) → 최소 소요기간 계산(임계경로 산정) → M/M 및 기간산정 후 CPM 수정 → 전체 일정 시각적 표현(간트차트)
- WBS: 목표 달성을 위한 활동 및 업무를 기능 단위로 세분화
- ==PERT/CPM==: 작업 선/후행 관계를 고려해서 전체 작업의 완료 시간을 결정함
- 임계경로(Critical Path): 프로젝트 완료를 위해 필요한 최소 소요 기간
- 간트차트(Gantt Chart): 업무별 시작/종료 시점을 바 형태로 표시
### 요구사항 분석
#### 현행 시스템 분석
##### 단계
현행 시스템 파악 → 플랫폼 기능 분석 → 현행 시스템 분석 → 미들웨어 분석
##### 현행 시스템 파악
기존 시스템의 기능, 성능, 문제점을 이해하고 신규 시스템의 개선, 유지, 변경 부분을 파악함
##### 플랫폼 기능 분석
- 연결 기능: 연결 장소 제공으로 다양한 교류 촉진
- 비용 감소 기능: 그룹간 처리 시간과 비용 절감
- 브랜드 신뢰 기능: 플랫폼 브랜드로 신뢰감 및 품질 보장
- 커뮤니티 형성: 그룹간 상호작용
==CPND(Contents → Platform → Network → Device)==: 컨텐츠를 플랫폼에 맞게 가공하고 네트워크를 통해 단말기로 서비스를 제공함, 가치사슬 표현 용어
##### 현행 시스템 분석
- 운영체제 분석
- 네트워크 분석
- DBMS 분석
##### ==미들웨어 분석==
양쪽 시스템을 연결하여 데이터를 교환할 수 있도록 중간 매개 역할을 하는 SW
- ==원격 프로시저 호출==: 클라이언트가 네트워크를 통해 원격으로 동작하는 프로시저 호출
- ==메시지 지향 미들웨어(MOL, Message Oriented Middleware)==: 비동기식 미들웨어, 클라이언트가 생성한 메시지를 비동기적으로 저장소에 저장하면서 다른 작업 처리 가능, 실시간 처리에 적합하지 않음
- ==ORB(Object Request Broker)==: 객체지향 시스템 사이에서 객체/서비스를 요청하면 결과 리턴을 지원함, 오버로딩과 유사
- ==DB 접속 미들웨어==: (ex. JDBC, ODBC) 애플리케이션과 DB 서버 간 데이터 접근을 용이하게 연결함
- ==TP 모니터(Transaction Processing Monitor)==: 분산 시스템에서 트랜젝션 처리를 감시하고 제어함
- ==엔터프라이즈 서비스 버스(Enterprise Service Bus)==: 메시지 기반으로 느슨한 결합 형태의 표준 인터페이스 통신을 지원, 기업 내외부 모든 시스템을 연동함
#### 요구공학
SW 요구사항을 식별/분석/문서화/관리 하는 과정
프로세스: 요구사항 도출 → 분석 → 명세 → 확인
##### 요구사항 도출
사용자 및 이해관계자의 요구사항 수집(인터뷰, 설문조사, 브레인스토밍, 워크샵 등)
##### 요구사항 분석
충돌하는 부분 수정, 현실성 검토, 우선순위 설정
##### 요구사항 명세
명세 기법
- ==정형 명세 기법==: 수학적 기호로 표기, 논리학 중심, 명세 오류 및 모호성 파악 유리
- ==비정형 명세 기법==: 자연어 및 그림으로 표기, 의사소통 용이
요구사항 분류
- ==기능 요구사항==: 기능, 서비스 정의
- ==비기능 요구사항==: 품질 특성, 제약사항 정의
##### 요구사항 분석 도구
==CASE(Computer Aided SW Engineering)==: 요구사항 자동 분석 및 분석 명세서 작성 도구
- ==상위 CASE==: 계획, 분석, 설계, 기획 단계 지원 (ex. 자료 흐름도 작성 도구)
- ==하위 CASE==: 구현(코드 작성), 테스트, 문서화 지원 (ex. 구문 편집기, 코드 생성기)
- ==통합 CASE==: 전반적인 sw 생명주기 통합 관리/운영 지원
==HIPO(Hierarchical Input Process Output)==: 하향식 SW 개발을 위한 문서화 도구
- 구성요소
	- 주요 프로세스: 시스템 내에서 주요 기능을 수행하는 프로세스
	- 하위 프로세스: 주요 프로세스를 구성하는 하위 세부 기능의 프로세스 단위
	- 입력/출력: 각 프로세스에 필요한 입출력 표현으로 데이터 흐름 파악
- HIPO Chart 종류
	- ==가시적 도표==: 시스템 전체 기능과 흐름을 계층(Tree) 구조로 표현
	- ==총체적 도표==: 프로그램을 구성하는 기능과 전반적인 정보 제공
	- ==세부적 도표==: 기능을 구성하는 세부 요소를 상세히 기술한 도표
#### 요구사항 분석 모델링
복잡한 시스템을 효과적으로 이해하고 개발하기 위해 간단한 모델로 표현하는 과정
##### 모델링 구분
- 기능적 모델링: 사용자 관점에서 시스템의 기능 표현 (ex. 사용사례 다이어그램)
- 정적 모델링: 시스템의 구조를 클래스 단위로 표현 (ex. 클래스 다이어그램)
- 동적 모델링: 시스템의 상호작용 및 동작 표현 (ex. 순서 다이어그램)
##### 구조적 분석 도구
- ==자료 흐름도(DFD, Data Flow Diagram)==: 자료의 이동 및 처리 과정을 도형으로 표시, 기능 중심 모델링
	- 처리과정(Process): 자료 변환/처리 과정
	- 자료 흐름(Data flow): 시스템 내 자료 이동 흐름
	- 자료 저장소(Data Store): 자료가 저장되는 파일, DB 표현
	- 단말(Terminator): 입출력 주체(사용자, 외부 시스템) 표시
![[image-20250307023324551.png]]
- ==자료사전(DD, Data Dictionary)==: DFD에 기술된 자료의 정의 및 설명 제공

| 기호     | 의미     | 설명                      |
| ------ | ------ | ----------------------- |
| =      | 자료의 정의 | 자료의 구성요소 표현             |
| +      | 자료의 연결 | 자료의 순차적 결합 상태 표현        |
| ( )    | 자료의 생략 | 필요에 따라 생략가능한 자료 표현      |
| [ \| ] | 자료의 선택 | 대안 중 하나를 선택할 수 있는 자료 표현 |
| { }    | 자료의 반복 | 자료가 반복될 수 있음을 표현        |
| **     | 자료의 설명 | 주석(추가 설명)               |
예시: 회원정보 = 회원정보 + 회원성명 + [전화번호 | 휴대폰번호] + (집주소)
- ==MiniSpec==: DFD의 각 처리의 수행 업무를 상세히 작성한 문서
- ==개체 관계도(ERD, Entity Relationship Diagram)==: 주로 DB에서 개체, 속성, 개체간 관계를 도식화하는 도구
![[image-20250307024739693.png]]
- ==상태전이도(STD, State Transition Diagram)==: 시스템 상태와 상태 간 전이를 모델화하는 도구
##### 객체지향 분석 방법론
-  ==럼바우(Rumbaugh) 방법 ==: ==객체 모델링 → 동적 모델링 → 기능 모델링==으로 나눠서 분석하는 기본적인 방법
	- 객체 모델링: ==객체 다이어그램==으로 시스템 객체, 속성, 연산, 관계 표현
	- 동적 모델링:  ==상태 다이어그램 ==으로 시간에 따른 객체 행동 및 상호작용 표현
	- 기능 모델링:  ==DFD ==로 데이터 흐름, 처리과정 표현
- 부치(Booch) 방법: 미시적/거시적 개발 프로세스 모두 사용, 시스템 구조와 행동을 상세히 표현
- Jacobson 방법: 유즈케이스 중심으로 요구사항과 시스템 간 상호작용을 분석
- Coad Yourdon 방법: E-R 다이어그램으로 객체 행위 모델링
- Wirfs-Brock 방법: 분석과 설계의 명확한 구분 없이 연속적으로 작업 수행
## Ch3. 소프트웨어 설계
### 소프트웨어 설계의 기본 원칙
#### 소프트웨어 설계
설계 종류
- 상위 설계
	- 아키텍쳐 설계: 시스템 전반적인 구조 설계
	- 데이터 설계 : 시스템에 필요한 정보 및 DB구조 설계
	- 인터페이스 정의 : 시스템 구조 간, 서브시스템 간 인터페이스 정의
	- 사용자 인터페이스 설계: 사용자 편의를 고려해서 상호작용 인터페이스 설계
- 하위 설계
	- 모듈 설계: 모듈 내부 명세, 알고리즘으로 구체화
	- 자료구조 설계: 데이터 저장 구조, 변수 등 상세 정보 설계
	- 알고리즘 설계: 처리 절차와 알고리즘 설계
설계 원리
- 분할과 정복: 큰 SW를 작은 서브시스템으로 나눠서 개발 계획
- 추상화: 공통의 성질을 묶어서 핵심적인 요소로 단순화 함
	- 과정 추상화 기법: 상위 수준에서 수행 흐름만 설계
	- 데이터 추상화 기법: 데이터 구조를 단순하게 표현
	- 제어 추상화 기법: 명령어를 단순하게 표현
- 단계적 분해: 기능을 세부화해서 단계적으로 설계, 복잡성 관리 (구현에 초점을 둔 분할과 정복)
- 모듈화: 개발가능한 독립적 모듈로 분리 (독립적인 개발/테스트/유지, 재사용에 유리)
- ==정보 은닉==: 외부에서 내부 정보의 직접 접근을 제한하여 데이터/기능 보호함(≒ 캡슐화)
- 결합도, 응집도: 좋은 설계는 ==결합도↓ 응집도↑==, 모듈간 독립성과 기능 집중성 유지
#### 설계 모델링
SW 구조와 기능을 그래픽적으로 표현하여 공통된 이해를 도움
##### 설계 모델링 유형
- ==구조(정적) 모델링==: 시스템 구성요소와 그 사이 구조적 관계를 표현, ==UML 정적 다이어그램== 활용
- ==행위(동적) 모델링==: SW 구성요소의 기능 수행 순서와 방식을 표현, 구성요소간 동적 상호작용 표현, ==UML 동적 다이어그램== 활용
##### 설계 절차 및 유형

| 순서  | 유형            | 산출물       | 설명                                       |
| --- | ------------- | --------- | ---------------------------------------- |
| 1   | 아키텍쳐 설계       | 시스템 아키텍쳐  | 전체 시스템과 서브시스템 간 관계 설계                    |
| 2   | 데이터베이스 설계     | 데이터베이스 명세 | 데이터 구조 설계, 데이터 관리의 일관성 확보                |
| 3   | 서브시스템 설계      | 서브시스템 명세  | 서비스스템의 기능/제약사항 명세, 시스템 기능을 독립적이고 명확하게 정의 |
| 4   | 컴포넌트 설계       | 컴포넌트 명세   | 각 기능별 컴포넌트 설계, 컴포넌트간 인터페이스 정의            |
| 5   | 자료구조와 알고리즘 설계 | 구현        | 데이터 저장 방식, 기본 연산 방법 설계                   |
** 요구사항 명세 기반으로 아키텍쳐/데이터베이스 설계 진행
==협약에 의한 설계==: 클래스의 조건을 명세해서 시스템간 안정성 유지를 목적으로 함
- ==선행조건==: 컴포넌트  오퍼레이션 사용 전 "참"이 되어야 하는 조건
- ==결과조건==: 컴포넌트 오퍼레이션 사용 후 "만족"해야 하는 조건
- ==불변조건==: 오퍼레이션 실행되는 동안 항상 "만족"해야 하는 조건
### 소프트웨어 아키텍처
#### SW 아키텍처
시스템의 기본 구조(골격), 고수준의 설계 지침 제공, 개발 방향성 제시
##### SW 아키텍처 특징(원칙)
- 간략성: 이해/추론이 쉽도록 간결하게 유지
- 추상화: 전반 구조를 추상화
- 가시성: 포함되어야 하는 모든 요소를 명확하게 시각적 표현
- 관점 모형: 다양한 이해당사자의 관심사에 따른 여러 모형을 제시하여 접근성 높임 (ex. 4+1 뷰)
- 의사소통 수단: 이해당사자 간 의사소통 수단으로 활용
##### SW 아키텍처 프레임워크 구성요소
- 아키텍처 명세서
- 이해관계자
- 관심사
- 관점
- 뷰: 이해관계자들의 견해를 반영하여 전체 시스템을 구성하고 표현함
##### 4 + 1 View Model
4: SW 구현의 4가지 관점 / 1: 사용자 관점
![[image-20250307034135286.png]]

- 논리뷰(Logical View): 설계자가 사용자 관점에서 시스템의 기능적 요구사항을 표현
- 구현뷰(Implementation View): 개발자가 SW 모듈 구성과 컴포넌트 다이어그램으로 구현 구조 표현
- 프로세스뷰(Process View): 시스템 통합 담당자가 프로그램 실행 시 시스템 상태, 동적 측면(동시성, 분산처리, 시스템 통합)을 표현
- 배치뷰(Deployment View): 시스템 엔지니어가 시스템의 물리적 배치, 네트워크 연결 뿐만 아니라 비기능적 요구사항(성능, 가용성, 신뢰성 등)을 표현
- 유즈케이스 뷰(Use Case View): 아키텍쳐 설계 및 검증 주도, 4개의 뷰 검증 용도
#### 소프트웨어 아키텍처 패턴
공통적인 설계 문제에 대한 일반적인 접근 방법을 제시함
##### 중요성
- 재사용성: 검증된 설계 방식을 재사용하여 개발 공수 절감
- 표준화: 표준화된 방식으로 설계하여 일관성↑ 유지보수성↑
- 개발 효율성: 일반적인 문제의 검증된 해결책을 제공하여 개발속도↑
- 문서화: 아키텍처 패턴은 이미 문서화되어 있어 구조를 쉽게 이해하고 공유할 수 있음
##### ==SW 아키텍처 패턴 종류==

| 유형                    | 설명                                                | 장점                           | 예시                          |
| --------------------- | ------------------------------------------------- | ---------------------------- | --------------------------- |
| 계층화 패턴                | 소프트웨어를 여러 계층으로 구분, 각 계층이 하위 계층의 기능을 사용하는 구조       | 계층간 독립성 유지보수 성 업그레이드         | OSI 7계층                     |
| 클라이언트-서버 패턴           | 서버가 여러 클라이언트의 서비스를 제공하는 구조, 요청과 응답                | 데이터관리,자원의 효율적인 활용            | 중앙 집중식 데이터 관리               |
| 마스터-슬레이브 패턴           | 마스터 컴포넌트가 작업을 슬레이브에 분산 시키면,슬레이브가 처리 결과를 마스터의 전달함  | 복잡한 작업에 처리 속도 향상             | 고성능 컴퓨팅 환경, 병렬 컴퓨팅          |
| 파이프-필터 패턴             | 데이터 스트림 처리 시스템에서<br>- 단계별 처리: 필터<br>- 결과 전달: 파이프  | 시스테 확장성, 재사용성 향상             | Unix 쉘 스크립트, 데이터 스트림 처리 시스템 |
| 브로커 패턴                | 분산시스템에서 컴포넌트간 통신(요청/처리결과)을 중재하는 브로커 컴포넌트를 사용하는 구조 | 시스템 유연성, 확장성 향상              | ORB 미들웨어, 오버로딩              |
| ==피어 투 피어 패턴==        | 모든 컴포넌트(피어)가 서버와 클라이언트 역할을 동시수행하는 구조              | 중앙집중식 서버에 의존하지 않는 분산 네트워크 구조 | 파일 공유시스템                    |
| 이벤트-버스 패턴             | 이벤트 버스로 메시지 발생하면 리스너가 구독하는 구조                     | 이벤트 기반 비동기 통신                | 메시징/알림 시스템                  |
| ==모델-뷰-컨트롤러 패턴(MVC)== | 모델(데이터 처리) + 뷰(UI) + 컨트롤러(입력 처리)로 구성              | 컴포넌트간 독립성, 재사용성, 확장성 향상      | 웹 어플리케이션                    |
| 블랙보드 패턴               | 여러 컴포넌트가 공유하는 중앙정보 저장소(블랙보드)를 통한 협업구조             | -                            | 복잡하고 명확한 해결 전략이 정의되지 않았을 때  |
| 인터프리터 패턴              | 특정 프로그래밍 언어의 해석/실행을 위한 컴포넌트 설계에 사용                | -                            | -                           |
### ==UML==